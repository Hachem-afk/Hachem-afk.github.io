/**
 * Crystal Fractal Raytracing Simulation
 * Advanced crystal rendering with recursive raytracing and chromatic dispersion
 */
class CrystalSimulation extends RaytracingEngine {
    constructor() {
        super();
        
        // Crystal-specific parameters
        this.crystalParams = {
            fractalIterations: 8,
            fractalPower: 8.0,
            crystalScale: 2.0,
            refractionIndex: 1.52, // Glass-like refraction
            dispersionStrength: 0.15,
            reflectionBounces: 3,
            crystalRotationSpeed: 0.3,
            growthAnimation: 1.0,
            crystalComplexity: 0.8
        };
        
        // Camera parameters
        this.camera = {
            position: [0, 0, 8],
            target: [0, 0, 0],
            fov: 45
        };
        
        // Lighting parameters
        this.lighting = {
            lightPosition: [5, 5, 5],
            lightColor: [1.0, 1.0, 1.0],
            lightIntensity: 1.5,
            ambientColor: [0.1, 0.1, 0.2],
            ambientIntensity: 0.3,
            environmentColor: [0.2, 0.3, 0.5]
        };
        
        // Fractal animation state
        this.fractalState = {
            rotation: [0, 0, 0],
            morphing: 0,
            pulsePhase: 0
        };
    }

    /**
     * Get vertex shader source
     */
    getVertexShader() {
        return `
            attribute vec2 a_position;
            varying vec2 v_uv;
            varying vec3 v_rayDir;
            
            uniform vec2 u_resolution;
            uniform vec3 u_cameraPos;
            uniform vec3 u_cameraTarget;
            uniform float u_fov;
            
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                
                // Calculate ray direction for raytracing
                vec2 screenPos = a_position;
                float aspect = u_resolution.x / u_resolution.y;
                float fovRad = radians(u_fov);
                
                // Camera setup
                vec3 forward = normalize(u_cameraTarget - u_cameraPos);
                vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
                vec3 up = cross(right, forward);
                
                // Ray direction
                vec3 rayDir = normalize(
                    right * screenPos.x * tan(fovRad * 0.5) * aspect +
                    up * screenPos.y * tan(fovRad * 0.5) +
                    forward
                );
                
                v_rayDir = rayDir;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
    }

    /**
     * Get fragment shader source with advanced crystal fractal raytracing
     */
    getFragmentShader() {
        return `
            precision highp float;
            
            varying vec2 v_uv;
            varying vec3 v_rayDir;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec3 u_cameraPos;
            
            // Crystal parameters
            uniform int u_fractalIterations;
            uniform float u_fractalPower;
            uniform float u_crystalScale;
            uniform float u_refractionIndex;
            uniform float u_dispersionStrength;
            uniform int u_reflectionBounces;
            uniform float u_crystalRotationSpeed;
            uniform float u_growthAnimation;
            uniform float u_crystalComplexity;
            
            // Lighting parameters
            uniform vec3 u_lightPosition;
            uniform vec3 u_lightColor;
            uniform float u_lightIntensity;
            uniform vec3 u_ambientColor;
            uniform float u_ambientIntensity;
            uniform vec3 u_environmentColor;
            
            // Fractal animation
            uniform vec3 u_fractalRotation;
            uniform float u_morphing;
            uniform float u_pulsePhase;
            
            const int MAX_STEPS = 128;
            const float MIN_DISTANCE = 0.001;
            const float MAX_DISTANCE = 20.0;
            const float PI = 3.14159265359;
            const float TAU = 6.28318530718;
            
            // Rotation matrices
            mat3 rotateX(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(
                    1.0, 0.0, 0.0,
                    0.0, c, -s,
                    0.0, s, c
                );
            }
            
            mat3 rotateY(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(
                    c, 0.0, s,
                    0.0, 1.0, 0.0,
                    -s, 0.0, c
                );
            }
            
            mat3 rotateZ(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(
                    c, -s, 0.0,
                    s, c, 0.0,
                    0.0, 0.0, 1.0
                );
            }
            
            // Complex number operations for fractals
            vec2 cmul(vec2 a, vec2 b) {
                return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
            }
            
            vec2 cdiv(vec2 a, vec2 b) {
                float denom = dot(b, b);
                return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;
            }
            
            // Mandelbulb distance function
            float mandelbulbDE(vec3 pos) {
                vec3 z = pos;
                float dr = 1.0;
                float r = 0.0;
                
                for (int i = 0; i < MAX_STEPS && i < u_fractalIterations; i++) {
                    r = length(z);
                    if (r > 2.0) break;
                    
                    // Convert to polar coordinates
                    float theta = acos(z.z / r);
                    float phi = atan(z.y, z.x);
                    dr = pow(r, u_fractalPower - 1.0) * u_fractalPower * dr + 1.0;
                    
                    // Scale and rotate
                    float zr = pow(r, u_fractalPower);
                    theta = theta * u_fractalPower;
                    phi = phi * u_fractalPower;
                    
                    // Convert back to cartesian coordinates
                    z = zr * vec3(
                        sin(theta) * cos(phi),
                        sin(phi) * sin(theta),
                        cos(theta)
                    );
                    z += pos;
                }
                
                return 0.5 * log(r) * r / dr;
            }
            
            // Julia set distance function
            float juliaDE(vec3 pos) {
                vec2 z = pos.xy;
                vec2 c = vec2(-0.8, 0.156 + u_morphing * 0.1);
                float dr = 1.0;
                
                for (int i = 0; i < 32; i++) {
                    if (dot(z, z) > 4.0) break;
                    
                    // dz = 2 * z * dz + 1
                    dr = 2.0 * length(z) * dr + 1.0;
                    
                    // z = z^2 + c
                    z = cmul(z, z) + c;
                }
                
                float r = length(z);
                return 0.5 * log(r) * r / dr;
            }
            
            // Crystal geometry with multiple fractal components
            float crystalSDF(vec3 pos) {
                // Apply rotation animation
                mat3 rot = rotateX(u_fractalRotation.x) * 
                          rotateY(u_fractalRotation.y) * 
                          rotateZ(u_fractalRotation.z);
                vec3 p = rot * pos;
                
                // Scale based on growth animation
                p /= u_crystalScale * u_growthAnimation;
                
                // Combine multiple fractal types
                float d1 = mandelbulbDE(p);
                float d2 = juliaDE(p + vec3(sin(u_time * 0.5), 0, 0)) * 2.0;
                
                // Morphing between different shapes
                float crystal = mix(d1, d2, sin(u_morphing) * 0.5 + 0.5);
                
                // Add crystal facets using octahedral symmetry
                vec3 fp = abs(p);
                float octahedron = (fp.x + fp.y + fp.z - 1.0) * 0.5;
                
                // Blend fractal with geometric crystal shape
                crystal = max(crystal, octahedron);
                
                // Add surface detail with noise
                float noise = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0) * 0.02;
                crystal += noise * u_crystalComplexity;
                
                return crystal * u_crystalScale * u_growthAnimation;
            }
            
            // Calculate normal using gradient
            vec3 getNormal(vec3 pos) {
                float eps = MIN_DISTANCE;
                vec3 normal = vec3(
                    crystalSDF(pos + vec3(eps, 0.0, 0.0)) - crystalSDF(pos - vec3(eps, 0.0, 0.0)),
                    crystalSDF(pos + vec3(0.0, eps, 0.0)) - crystalSDF(pos - vec3(0.0, eps, 0.0)),
                    crystalSDF(pos + vec3(0.0, 0.0, eps)) - crystalSDF(pos - vec3(0.0, 0.0, eps))
                );
                return normalize(normal);
            }
            
            // Raymarching
            float raymarch(vec3 rayPos, vec3 rayDir) {
                float t = 0.0;
                
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 pos = rayPos + rayDir * t;
                    float dist = crystalSDF(pos);
                    
                    if (dist < MIN_DISTANCE) {
                        return t;
                    }
                    
                    if (t > MAX_DISTANCE) {
                        break;
                    }
                    
                    t += dist * 0.8; // Conservative step size for accuracy
                }
                
                return -1.0;
            }
            
            // Fresnel reflection calculation
            float fresnel(vec3 incident, vec3 normal, float ior) {
                float cosI = -dot(incident, normal);
                float sinT2 = ior * ior * (1.0 - cosI * cosI);
                
                if (sinT2 > 1.0) return 1.0; // Total internal reflection
                
                float cosT = sqrt(1.0 - sinT2);
                float rs = (ior * cosI - cosT) / (ior * cosI + cosT);
                float rp = (cosI - ior * cosT) / (cosI + ior * cosT);
                
                return (rs * rs + rp * rp) * 0.5;
            }
            
            // Calculate refracted ray
            vec3 refract(vec3 incident, vec3 normal, float ior) {
                float cosI = -dot(incident, normal);
                float sinT2 = ior * ior * (1.0 - cosI * cosI);
                
                if (sinT2 > 1.0) {
                    return reflect(incident, normal); // Total internal reflection
                }
                
                float cosT = sqrt(1.0 - sinT2);
                return ior * incident + (ior * cosI - cosT) * normal;
            }
            
            // Environment mapping for reflections
            vec3 getEnvironmentColor(vec3 rayDir) {
                // Simple procedural environment
                float y = rayDir.y * 0.5 + 0.5;
                vec3 horizon = vec3(0.7, 0.9, 1.0);
                vec3 zenith = vec3(0.2, 0.4, 0.8);
                
                vec3 envColor = mix(horizon, zenith, y);
                
                // Add some stars
                float stars = smoothstep(0.95, 1.0, 
                    sin(rayDir.x * 100.0) * sin(rayDir.y * 100.0) * sin(rayDir.z * 100.0));
                envColor += vec3(stars) * 0.5;
                
                return envColor * u_environmentColor;
            }
            
            // Chromatic dispersion effect
            vec3 getDispersedColor(vec3 rayPos, vec3 rayDir, vec3 normal, int bounces) {
                vec3 color = vec3(0.0);
                
                // Sample multiple wavelengths for dispersion
                float wavelengths[3];
                wavelengths[0] = 650.0; // Red
                wavelengths[1] = 550.0; // Green
                wavelengths[2] = 450.0; // Blue
                
                for (int i = 0; i < 3; i++) {
                    // Wavelength-dependent refractive index
                    float ior = u_refractionIndex + u_dispersionStrength * (550.0 - wavelengths[i]) / 200.0;
                    
                    vec3 refractedDir = refract(rayDir, normal, ior);
                    
                    // Trace refracted ray
                    float t = raymarch(rayPos + normal * MIN_DISTANCE * 2.0, refractedDir);
                    
                    if (t > 0.0) {
                        vec3 hitPos = rayPos + normal * MIN_DISTANCE * 2.0 + refractedDir * t;
                        vec3 hitNormal = getNormal(hitPos);
                        
                        // Exit the crystal
                        vec3 exitDir = refract(refractedDir, -hitNormal, 1.0 / ior);
                        vec3 exitColor = getEnvironmentColor(exitDir);
                        
                        // Apply Beer's law for absorption
                        float absorption = exp(-t * 0.1);
                        
                        if (i == 0) color.r += exitColor.r * absorption;
                        else if (i == 1) color.g += exitColor.g * absorption;
                        else color.b += exitColor.b * absorption;
                    } else {
                        // Ray didn't hit anything, use environment
                        vec3 envColor = getEnvironmentColor(refractedDir);
                        if (i == 0) color.r += envColor.r;
                        else if (i == 1) color.g += envColor.g;
                        else color.b += envColor.b;
                    }
                }
                
                return color;
            }
            
            // Main lighting calculation
            vec3 calculateLighting(vec3 pos, vec3 normal, vec3 viewDir) {
                vec3 lightDir = normalize(u_lightPosition - pos);
                float NdotL = max(0.0, dot(normal, lightDir));
                
                // Diffuse lighting
                vec3 diffuse = u_lightColor * u_lightIntensity * NdotL;
                
                // Specular lighting (Blinn-Phong)
                vec3 halfDir = normalize(lightDir + viewDir);
                float NdotH = max(0.0, dot(normal, halfDir));
                float specular = pow(NdotH, 64.0);
                vec3 specularColor = u_lightColor * specular * 0.8;
                
                // Ambient lighting
                vec3 ambient = u_ambientColor * u_ambientIntensity;
                
                return diffuse + specularColor + ambient;
            }
            
            void main() {
                vec3 rayPos = u_cameraPos;
                vec3 rayDir = normalize(v_rayDir);
                
                // Initial ray intersection
                float t = raymarch(rayPos, rayDir);
                
                if (t > 0.0) {
                    vec3 hitPos = rayPos + rayDir * t;
                    vec3 normal = getNormal(hitPos);
                    
                    // Calculate Fresnel reflection
                    float fresnelFactor = fresnel(rayDir, normal, u_refractionIndex);
                    
                    // Reflection component
                    vec3 reflectedDir = reflect(rayDir, normal);
                    vec3 reflectionColor = getEnvironmentColor(reflectedDir);
                    
                    // Enhanced reflection for crystal surfaces
                    reflectionColor *= 1.5;
                    
                    // Refraction component with chromatic dispersion
                    vec3 refractionColor = getDispersedColor(hitPos, rayDir, normal, u_reflectionBounces);
                    
                    // Base crystal color with internal lighting
                    vec3 lighting = calculateLighting(hitPos, normal, -rayDir);
                    vec3 crystalColor = vec3(0.9, 0.95, 1.0) * lighting;
                    
                    // Internal caustics effect
                    float caustics = sin(hitPos.x * 20.0 + u_time) * 
                                   sin(hitPos.y * 15.0 + u_time * 1.2) * 
                                   sin(hitPos.z * 18.0 + u_time * 0.8);
                    caustics = max(0.0, caustics) * 0.3;
                    
                    // Combine reflection and refraction
                    vec3 finalColor = mix(refractionColor, reflectionColor, fresnelFactor);
                    finalColor += crystalColor * 0.3;
                    finalColor += vec3(caustics) * u_lightColor;
                    
                    // Add subtle rainbow dispersion on edges
                    float edgeFactor = 1.0 - abs(dot(normal, -rayDir));
                    vec3 rainbowColor = vec3(
                        sin(edgeFactor * PI + u_time),
                        sin(edgeFactor * PI + u_time + 2.0),
                        sin(edgeFactor * PI + u_time + 4.0)
                    ) * 0.5 + 0.5;
                    
                    finalColor += rainbowColor * edgeFactor * edgeFactor * 0.2;
                    
                    // Enhance brightness for crystal effect
                    finalColor *= 1.2;
                    
                    // Tone mapping
                    finalColor = finalColor / (finalColor + vec3(1.0));
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                } else {
                    // Render environment
                    vec3 envColor = getEnvironmentColor(rayDir);
                    gl_FragColor = vec4(envColor, 1.0);
                }
            }
        `;
    }

    /**
     * Update shader uniforms with crystal-specific parameters
     */
    updateUniforms() {
        super.updateUniforms();
        
        const gl = this.gl;
        if (!this.program) return;
        
        gl.useProgram(this.program);
        
        // Camera uniforms
        let location = gl.getUniformLocation(this.program, 'u_cameraPos');
        if (location) gl.uniform3fv(location, this.camera.position);
        
        location = gl.getUniformLocation(this.program, 'u_cameraTarget');
        if (location) gl.uniform3fv(location, this.camera.target);
        
        location = gl.getUniformLocation(this.program, 'u_fov');
        if (location) gl.uniform1f(location, this.camera.fov);
        
        // Crystal parameter uniforms
        location = gl.getUniformLocation(this.program, 'u_fractalIterations');
        if (location) gl.uniform1i(location, this.crystalParams.fractalIterations);
        
        location = gl.getUniformLocation(this.program, 'u_fractalPower');
        if (location) gl.uniform1f(location, this.crystalParams.fractalPower);
        
        location = gl.getUniformLocation(this.program, 'u_crystalScale');
        if (location) gl.uniform1f(location, this.crystalParams.crystalScale);
        
        location = gl.getUniformLocation(this.program, 'u_refractionIndex');
        if (location) gl.uniform1f(location, this.crystalParams.refractionIndex);
        
        location = gl.getUniformLocation(this.program, 'u_dispersionStrength');
        if (location) gl.uniform1f(location, this.crystalParams.dispersionStrength);
        
        location = gl.getUniformLocation(this.program, 'u_reflectionBounces');
        if (location) gl.uniform1i(location, this.crystalParams.reflectionBounces);
        
        location = gl.getUniformLocation(this.program, 'u_crystalRotationSpeed');
        if (location) gl.uniform1f(location, this.crystalParams.crystalRotationSpeed);
        
        location = gl.getUniformLocation(this.program, 'u_growthAnimation');
        if (location) gl.uniform1f(location, this.crystalParams.growthAnimation);
        
        location = gl.getUniformLocation(this.program, 'u_crystalComplexity');
        if (location) gl.uniform1f(location, this.crystalParams.crystalComplexity);
        
        // Lighting uniforms
        location = gl.getUniformLocation(this.program, 'u_lightPosition');
        if (location) gl.uniform3fv(location, this.lighting.lightPosition);
        
        location = gl.getUniformLocation(this.program, 'u_lightColor');
        if (location) gl.uniform3fv(location, this.lighting.lightColor);
        
        location = gl.getUniformLocation(this.program, 'u_lightIntensity');
        if (location) gl.uniform1f(location, this.lighting.lightIntensity);
        
        location = gl.getUniformLocation(this.program, 'u_ambientColor');
        if (location) gl.uniform3fv(location, this.lighting.ambientColor);
        
        location = gl.getUniformLocation(this.program, 'u_ambientIntensity');
        if (location) gl.uniform1f(location, this.lighting.ambientIntensity);
        
        location = gl.getUniformLocation(this.program, 'u_environmentColor');
        if (location) gl.uniform3fv(location, this.lighting.environmentColor);
        
        // Fractal animation uniforms
        location = gl.getUniformLocation(this.program, 'u_fractalRotation');
        if (location) gl.uniform3fv(location, this.fractalState.rotation);
        
        location = gl.getUniformLocation(this.program, 'u_morphing');
        if (location) gl.uniform1f(location, this.fractalState.morphing);
        
        location = gl.getUniformLocation(this.program, 'u_pulsePhase');
        if (location) gl.uniform1f(location, this.fractalState.pulsePhase);
    }

    /**
     * Render crystal simulation
     */
    render() {
        // Update crystal animation
        this.updateCrystalAnimation();
        
        // Update camera animation
        this.updateCamera();
        
        // Update lighting
        this.updateLighting();
        
        // Call parent render method
        super.render();
        
        // Update ray count for crystal simulation
        const steps = Math.min(128, this.quality.raySteps);
        const iterations = this.crystalParams.fractalIterations;
        const bounces = this.crystalParams.reflectionBounces;
        this.rayCount = this.canvas.width * this.canvas.height * steps * iterations * bounces;
    }

    /**
     * Update crystal fractal animation
     */
    updateCrystalAnimation() {
        const time = this.currentTime;
        const speed = this.crystalParams.crystalRotationSpeed;
        
        // Rotate the crystal on multiple axes
        this.fractalState.rotation[0] = time * speed * 0.7;
        this.fractalState.rotation[1] = time * speed * 0.5;
        this.fractalState.rotation[2] = time * speed * 0.3;
        
        // Morphing between different fractal parameters
        this.fractalState.morphing = Math.sin(time * 0.2) * 2.0;
        
        // Pulsing effect for growth animation
        this.fractalState.pulsePhase = time * 1.5;
        this.crystalParams.growthAnimation = 0.8 + Math.sin(this.fractalState.pulsePhase) * 0.2;
        
        // Animate fractal power for shape morphing
        this.crystalParams.fractalPower = 8.0 + Math.sin(time * 0.1) * 2.0;
        
        // Animate crystal complexity
        this.crystalParams.crystalComplexity = 0.8 + Math.sin(time * 0.15) * 0.2;
    }

    /**
     * Update camera animation
     */
    updateCamera() {
        const time = this.currentTime;
        
        // Orbit camera around the crystal
        const radius = 8.0;
        const height = Math.sin(time * 0.2) * 2.0;
        const angle = time * 0.1;
        
        this.camera.position[0] = Math.cos(angle) * radius;
        this.camera.position[1] = height;
        this.camera.position[2] = Math.sin(angle) * radius;
        
        // Always look at the center
        this.camera.target = [0, 0, 0];
        
        // Animate field of view for dramatic effect
        this.camera.fov = 45 + Math.sin(time * 0.3) * 5;
    }

    /**
     * Update dynamic lighting
     */
    updateLighting() {
        const time = this.currentTime;
        
        // Animate light position in a complex pattern
        this.lighting.lightPosition[0] = Math.cos(time * 0.3) * 8 + Math.sin(time * 0.7) * 3;
        this.lighting.lightPosition[1] = 5 + Math.sin(time * 0.4) * 3;
        this.lighting.lightPosition[2] = Math.sin(time * 0.3) * 8 + Math.cos(time * 0.5) * 3;
        
        // Animate light intensity
        this.lighting.lightIntensity = 1.5 + Math.sin(time * 0.8) * 0.3;
        
        // Color cycling for dramatic effect
        const hue = time * 0.1;
        this.lighting.lightColor[0] = 0.8 + Math.sin(hue) * 0.2;
        this.lighting.lightColor[1] = 0.8 + Math.sin(hue + 2.0) * 0.2;
        this.lighting.lightColor[2] = 0.8 + Math.sin(hue + 4.0) * 0.2;
        
        // Animate ambient lighting
        this.lighting.ambientIntensity = 0.3 + Math.sin(time * 0.2) * 0.1;
        
        // Environment color shifts
        this.lighting.environmentColor[0] = 0.2 + Math.sin(time * 0.05) * 0.1;
        this.lighting.environmentColor[1] = 0.3 + Math.sin(time * 0.07 + 1.0) * 0.1;
        this.lighting.environmentColor[2] = 0.5 + Math.sin(time * 0.09 + 2.0) * 0.1;
    }

    /**
     * Adjust quality for crystal simulation
     */
    adjustQuality() {
        super.adjustQuality();
        
        // Crystal-specific quality adjustments
        const performance = this.performanceMonitor.getPerformanceLevel();
        
        switch (performance) {
            case 'poor':
                this.crystalParams.fractalIterations = 4;
                this.crystalParams.reflectionBounces = 1;
                this.crystalParams.dispersionStrength = 0.05;
                break;
                
            case 'fair':
                this.crystalParams.fractalIterations = 6;
                this.crystalParams.reflectionBounces = 2;
                this.crystalParams.dispersionStrength = 0.1;
                break;
                
            case 'good':
                this.crystalParams.fractalIterations = 8;
                this.crystalParams.reflectionBounces = 3;
                this.crystalParams.dispersionStrength = 0.15;
                break;
                
            case 'excellent':
                this.crystalParams.fractalIterations = 12;
                this.crystalParams.reflectionBounces = 4;
                this.crystalParams.dispersionStrength = 0.2;
                break;
        }
    }

    /**
     * Get crystal simulation specific statistics
     */
    getStats() {
        const baseStats = super.getStats();
        
        return {
            ...baseStats,
            crystalParams: { ...this.crystalParams },
            camera: { ...this.camera },
            lighting: { ...this.lighting },
            fractalState: { ...this.fractalState },
            estimatedFractals: this.crystalParams.fractalIterations
        };
    }

    /**
     * Handle interactive controls (for future enhancement)
     */
    setInteractiveMode(enabled) {
        this.interactiveMode = enabled;
        if (enabled) {
            console.log('Crystal interactive mode enabled');
            // Could add mouse controls for crystal rotation, etc.
        }
    }

    /**
     * Export crystal parameters for saving/loading
     */
    exportParameters() {
        return {
            crystalParams: { ...this.crystalParams },
            lighting: { ...this.lighting },
            camera: { ...this.camera }
        };
    }

    /**
     * Import crystal parameters
     */
    importParameters(params) {
        if (params.crystalParams) {
            this.crystalParams = { ...this.crystalParams, ...params.crystalParams };
        }
        if (params.lighting) {
            this.lighting = { ...this.lighting, ...params.lighting };
        }
        if (params.camera) {
            this.camera = { ...this.camera, ...params.camera };
        }
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CrystalSimulation;
}/**
 * Ocean Raytracing Simulation
 * Advanced ocean surface rendering with volumetric effects and caustics
 */
class OceanSimulation extends RaytracingEngine {
    constructor() {
        super();
        
        // Ocean-specific parameters
        this.oceanParams = {
            waveHeight: 0.8,
            waveFrequency: 0.5,
            waveSpeed: 1.2,
            foamAmount: 0.3,
            transparency: 0.7,
            refractionIndex: 1.33,
            causticsIntensity: 0.8,
            volumetricDensity: 0.4
        };
        
        // Camera parameters
        this.camera = {
            position: [0, 5, 10],
            target: [0, 0, 0],
            fov: 60
        };
        
        // Light parameters
        this.lighting = {
            sunDirection: [-0.3, -0.8, -0.5],
            sunColor: [1.0, 1.0, 1.0],
            sunIntensity: 1.0,
            skyColor: [0.4, 0.7, 1.0],
            oceanDeepColor: [0.02, 0.1, 0.3],
            oceanShallowColor: [0.1, 0.4, 0.7]
        };
    }

    /**
     * Get vertex shader source
     */
    getVertexShader() {
        return `
            attribute vec2 a_position;
            varying vec2 v_uv;
            varying vec3 v_rayDir;
            
            uniform vec2 u_resolution;
            uniform vec3 u_cameraPos;
            uniform vec3 u_cameraTarget;
            uniform float u_fov;
            
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                
                // Calculate ray direction for raytracing
                vec2 screenPos = a_position;
                float aspect = u_resolution.x / u_resolution.y;
                float fovRad = radians(u_fov);
                
                // Camera setup
                vec3 forward = normalize(u_cameraTarget - u_cameraPos);
                vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
                vec3 up = cross(right, forward);
                
                // Ray direction
                vec3 rayDir = normalize(
                    right * screenPos.x * tan(fovRad * 0.5) * aspect +
                    up * screenPos.y * tan(fovRad * 0.5) +
                    forward
                );
                
                v_rayDir = rayDir;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
    }

    /**
     * Get fragment shader source
     */
    getFragmentShader() {
        return `
            precision highp float;
            
            varying vec2 v_uv;
            varying vec3 v_rayDir;
            
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec3 u_cameraPos;
            
            // Ocean parameters
            uniform float u_waveHeight;
            uniform float u_waveFrequency;
            uniform float u_waveSpeed;
            uniform float u_foamAmount;
            uniform float u_transparency;
            uniform float u_refractionIndex;
            uniform float u_causticsIntensity;
            uniform float u_volumetricDensity;
            
            // Lighting parameters
            uniform vec3 u_sunDirection;
            uniform vec3 u_sunColor;
            uniform float u_sunIntensity;
            uniform vec3 u_skyColor;
            uniform vec3 u_oceanDeepColor;
            uniform vec3 u_oceanShallowColor;
            
            const int MAX_STEPS = 64;
            const float MIN_DISTANCE = 0.001;
            const float MAX_DISTANCE = 100.0;
            const float PI = 3.14159265359;
            
            // Noise functions
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for (int i = 0; i < 4; i++) {
                    value += amplitude * noise(p * frequency);
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                
                return value;
            }
            
            // Ocean height function
            float getOceanHeight(vec2 pos) {
                vec2 wavePos = pos * u_waveFrequency + u_time * u_waveSpeed;
                
                float height = 0.0;
                
                // Primary waves
                height += sin(wavePos.x * 2.0 + u_time * 1.5) * 0.4;
                height += sin(wavePos.y * 1.5 + u_time * 1.2) * 0.3;
                height += sin((wavePos.x + wavePos.y) * 1.0 + u_time * 0.8) * 0.2;
                
                // Secondary waves using noise
                height += fbm(wavePos * 2.0) * 0.3;
                height += fbm(wavePos * 4.0) * 0.15;
                
                return height * u_waveHeight;
            }
            
            // Calculate ocean normal
            vec3 getOceanNormal(vec2 pos) {
                float eps = 0.01;
                float h0 = getOceanHeight(pos);
                float hx = getOceanHeight(pos + vec2(eps, 0.0));
                float hy = getOceanHeight(pos + vec2(0.0, eps));
                
                vec3 normal = normalize(vec3(h0 - hx, eps, h0 - hy));
                return normal;
            }
            
            // Ray-ocean intersection
            float intersectOcean(vec3 rayPos, vec3 rayDir) {
                float t = 0.0;
                
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 pos = rayPos + rayDir * t;
                    float oceanHeight = getOceanHeight(pos.xz);
                    float height = pos.y - oceanHeight;
                    
                    if (height < MIN_DISTANCE) {
                        return t;
                    }
                    
                    if (t > MAX_DISTANCE) {
                        break;
                    }
                    
                    t += max(height * 0.5, MIN_DISTANCE);
                }
                
                return -1.0;
            }
            
            // Fresnel reflection calculation
            float fresnel(vec3 incident, vec3 normal, float ior) {
                float cosI = -dot(incident, normal);
                float sinT2 = ior * ior * (1.0 - cosI * cosI);
                
                if (sinT2 > 1.0) return 1.0; // Total internal reflection
                
                float cosT = sqrt(1.0 - sinT2);
                float rs = (ior * cosI - cosT) / (ior * cosI + cosT);
                float rp = (cosI - ior * cosT) / (cosI + ior * cosT);
                
                return (rs * rs + rp * rp) * 0.5;
            }
            
            // Sky color calculation
            vec3 getSkyColor(vec3 rayDir) {
                float sunDot = max(0.0, dot(rayDir, -u_sunDirection));
                vec3 color = u_skyColor;
                
                // Sun disc - pure white
                color += vec3(1.0) * pow(sunDot, 512.0) * 3.0;
                
                // Sun glow - slight blue tint
                color += vec3(1.0, 1.0, 1.1) * pow(sunDot, 64.0) * 0.8;
                
                // Horizon gradient - more realistic blue
                float horizon = abs(rayDir.y);
                vec3 horizonColor = vec3(0.8, 0.9, 1.0);
                color = mix(horizonColor, color, pow(horizon, 0.3));
                
                return color;
            }
            
            // Caustics calculation
            float getCaustics(vec3 pos, vec3 normal) {
                vec2 causticsPos = pos.xz * 3.0 + u_time * 0.5;
                
                // Multiple layers of caustics
                float caustics = 0.0;
                caustics += max(0.0, sin(causticsPos.x * 8.0) * cos(causticsPos.y * 6.0));
                caustics += max(0.0, sin((causticsPos.x + causticsPos.y) * 4.0)) * 0.5;
                caustics += fbm(causticsPos * 2.0) * 0.3;
                
                // Modulate by surface normal
                caustics *= max(0.0, dot(normal, -u_sunDirection));
                
                return caustics * u_causticsIntensity;
            }
            
            // Volumetric scattering in water
            vec3 getVolumetricScattering(vec3 rayPos, vec3 rayDir, float depth) {
                vec3 scattering = vec3(0.0);
                float stepSize = depth / 8.0;
                
                for (int i = 0; i < 8; i++) {
                    vec3 pos = rayPos + rayDir * (float(i) * stepSize);
                    float density = u_volumetricDensity * exp(-pos.y * 0.1);
                    
                    // Light scattering - pure white light
                    float sunScatter = max(0.0, dot(rayDir, -u_sunDirection));
                    vec3 scatter = vec3(1.0) * pow(sunScatter, 4.0) * density * stepSize;
                    
                    scattering += scatter;
                }
                
                return scattering * 0.1;
            }
            
            void main() {
                vec3 rayPos = u_cameraPos;
                vec3 rayDir = normalize(v_rayDir);
                
                // Intersect with ocean
                float t = intersectOcean(rayPos, rayDir);
                
                if (t > 0.0) {
                    vec3 hitPos = rayPos + rayDir * t;
                    vec3 normal = getOceanNormal(hitPos.xz);
                    
                    // Lighting calculations
                    vec3 lightDir = -u_sunDirection;
                    float NdotL = max(0.0, dot(normal, lightDir));
                    
                    // Ocean surface color
                    float depth = max(0.0, -hitPos.y);
                    vec3 waterColor = mix(u_oceanShallowColor, u_oceanDeepColor, 
                                         min(depth / 10.0, 1.0));
                    
                    // Fresnel reflection
                    float fresnelFactor = fresnel(rayDir, normal, u_refractionIndex);
                    vec3 reflectedDir = reflect(rayDir, normal);
                    vec3 skyReflection = getSkyColor(reflectedDir);
                    
                    // Caustics
                    float caustics = getCaustics(hitPos, normal);
                    
                    // Foam calculation
                    float foam = 0.0;
                    float waveGradient = length(vec2(
                        getOceanHeight(hitPos.xz + vec2(0.1, 0.0)) - getOceanHeight(hitPos.xz - vec2(0.1, 0.0)),
                        getOceanHeight(hitPos.xz + vec2(0.0, 0.1)) - getOceanHeight(hitPos.xz - vec2(0.0, 0.1))
                    ));
                    foam = smoothstep(0.5, 1.0, waveGradient) * u_foamAmount;
                    
                    // Combine lighting - more realistic water
                    vec3 diffuse = waterColor * vec3(1.0) * NdotL * u_sunIntensity;
                    vec3 ambient = waterColor * u_skyColor * 0.2;
                    vec3 reflection = skyReflection * fresnelFactor * 1.2;
                    
                    // Add caustics - pure white light
                    diffuse += vec3(1.0) * caustics * 0.3;
                    
                    // Add foam
                    vec3 foamColor = vec3(1.0) * foam;
                    
                    // Volumetric scattering
                    vec3 volumetric = getVolumetricScattering(rayPos, rayDir, t);
                    
                    // Final color composition
                    vec3 finalColor = diffuse + ambient + reflection + foamColor + volumetric;
                    
                    // Atmospheric perspective - use pure blue
                    float distance = t / MAX_DISTANCE;
                    vec3 atmosphericColor = vec3(0.4, 0.7, 1.0);
                    finalColor = mix(finalColor, atmosphericColor, distance * distance * 0.3);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                } else {
                    // Render sky
                    vec3 skyColor = getSkyColor(rayDir);
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            }
        `;
    }

    /**
     * Update shader uniforms with ocean-specific parameters
     */
    updateUniforms() {
        super.updateUniforms();
        
        const gl = this.gl;
        if (!this.program) return;
        
        gl.useProgram(this.program);
        
        // Camera uniforms
        let location = gl.getUniformLocation(this.program, 'u_cameraPos');
        if (location) gl.uniform3fv(location, this.camera.position);
        
        location = gl.getUniformLocation(this.program, 'u_cameraTarget');
        if (location) gl.uniform3fv(location, this.camera.target);
        
        location = gl.getUniformLocation(this.program, 'u_fov');
        if (location) gl.uniform1f(location, this.camera.fov);
        
        // Ocean parameter uniforms
        location = gl.getUniformLocation(this.program, 'u_waveHeight');
        if (location) gl.uniform1f(location, this.oceanParams.waveHeight);
        
        location = gl.getUniformLocation(this.program, 'u_waveFrequency');
        if (location) gl.uniform1f(location, this.oceanParams.waveFrequency);
        
        location = gl.getUniformLocation(this.program, 'u_waveSpeed');
        if (location) gl.uniform1f(location, this.oceanParams.waveSpeed);
        
        location = gl.getUniformLocation(this.program, 'u_foamAmount');
        if (location) gl.uniform1f(location, this.oceanParams.foamAmount);
        
        location = gl.getUniformLocation(this.program, 'u_transparency');
        if (location) gl.uniform1f(location, this.oceanParams.transparency);
        
        location = gl.getUniformLocation(this.program, 'u_refractionIndex');
        if (location) gl.uniform1f(location, this.oceanParams.refractionIndex);
        
        location = gl.getUniformLocation(this.program, 'u_causticsIntensity');
        if (location) gl.uniform1f(location, this.oceanParams.causticsIntensity);
        
        location = gl.getUniformLocation(this.program, 'u_volumetricDensity');
        if (location) gl.uniform1f(location, this.oceanParams.volumetricDensity);
        
        // Lighting uniforms
        location = gl.getUniformLocation(this.program, 'u_sunDirection');
        if (location) gl.uniform3fv(location, this.lighting.sunDirection);
        
        location = gl.getUniformLocation(this.program, 'u_sunColor');
        if (location) gl.uniform3fv(location, this.lighting.sunColor);
        
        location = gl.getUniformLocation(this.program, 'u_sunIntensity');
        if (location) gl.uniform1f(location, this.lighting.sunIntensity);
        
        location = gl.getUniformLocation(this.program, 'u_skyColor');
        if (location) gl.uniform3fv(location, this.lighting.skyColor);
        
        location = gl.getUniformLocation(this.program, 'u_oceanDeepColor');
        if (location) gl.uniform3fv(location, this.lighting.oceanDeepColor);
        
        location = gl.getUniformLocation(this.program, 'u_oceanShallowColor');
        if (location) gl.uniform3fv(location, this.lighting.oceanShallowColor);
    }

    /**
     * Render ocean simulation
     */
    render() {
        // Update camera animation
        this.updateCamera();
        
        // Update lighting based on time
        this.updateLighting();
        
        // Call parent render method
        super.render();
        
        // Update ray count for ocean simulation
        const steps = Math.min(64, this.quality.raySteps);
        this.rayCount = this.canvas.width * this.canvas.height * steps;
    }

    /**
     * Update camera animation
     */
    updateCamera() {
        const time = this.currentTime;
        
        // Smooth camera movement
        this.camera.position[0] = Math.sin(time * 0.2) * 8;
        this.camera.position[1] = 5 + Math.sin(time * 0.3) * 2;
        this.camera.position[2] = 10 + Math.cos(time * 0.15) * 3;
        
        // Look at ocean surface
        this.camera.target[0] = Math.sin(time * 0.1) * 2;
        this.camera.target[1] = 0;
        this.camera.target[2] = Math.cos(time * 0.1) * 2;
    }

    /**
     * Update lighting based on time of day
     */
    updateLighting() {
        const time = this.currentTime;
        
        // Animate sun direction
        const sunAngle = time * 0.1;
        this.lighting.sunDirection[0] = Math.sin(sunAngle) * 0.6;
        this.lighting.sunDirection[1] = -0.8 + Math.cos(sunAngle) * 0.3;
        this.lighting.sunDirection[2] = -0.5;
        
        // Adjust sun intensity based on angle
        const sunHeight = this.lighting.sunDirection[1];
        this.lighting.sunIntensity = Utils.clamp(1.2 + sunHeight, 0.3, 1.5);
        
        // Time of day color variations
        const dayFactor = Utils.clamp(-sunHeight, 0, 1);
        
        // Sunset/sunrise colors
        const sunsetColor = [1.0, 0.6, 0.3];
        const dayColor = [1.0, 0.95, 0.8];
        
        this.lighting.sunColor[0] = Utils.lerp(dayColor[0], sunsetColor[0], dayFactor);
        this.lighting.sunColor[1] = Utils.lerp(dayColor[1], sunsetColor[1], dayFactor);
        this.lighting.sunColor[2] = Utils.lerp(dayColor[2], sunsetColor[2], dayFactor);
        
        // Sky color variations
        const daySky = [0.5, 0.7, 1.0];
        const sunsetSky = [1.0, 0.4, 0.2];
        
        this.lighting.skyColor[0] = Utils.lerp(daySky[0], sunsetSky[0], dayFactor);
        this.lighting.skyColor[1] = Utils.lerp(daySky[1], sunsetSky[1], dayFactor);
        this.lighting.skyColor[2] = Utils.lerp(daySky[2], sunsetSky[2], dayFactor);
    }

    /**
     * Adjust quality for ocean simulation
     */
    adjustQuality() {
        super.adjustQuality();
        
        // Ocean-specific quality adjustments
        const performance = this.performanceMonitor.getPerformanceLevel();
        
        switch (performance) {
            case 'poor':
                this.oceanParams.volumetricDensity = 0.2;
                this.oceanParams.causticsIntensity = 0.4;
                break;
                
            case 'fair':
                this.oceanParams.volumetricDensity = 0.3;
                this.oceanParams.causticsIntensity = 0.6;
                break;
                
            case 'good':
                this.oceanParams.volumetricDensity = 0.4;
                this.oceanParams.causticsIntensity = 0.8;
                break;
                
            case 'excellent':
                this.oceanParams.volumetricDensity = 0.5;
                this.oceanParams.causticsIntensity = 1.0;
                break;
        }
    }

    /**
     * Get ocean simulation specific statistics
     */
    getStats() {
        const baseStats = super.getStats();
        
        return {
            ...baseStats,
            oceanParams: { ...this.oceanParams },
            camera: { ...this.camera },
            lighting: { ...this.lighting }
        };
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = OceanSimulation;
}/**
 * Advanced particle system for interactive background
 */
class ParticleSystem {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particles = [];
        this.connections = [];
        this.mouseX = 0;
        this.mouseY = 0;
        
        // Configuration
        this.config = {
            maxParticles: Utils.isMobile() ? 40 : 80,
            connectionDistance: 120,
            mouseInfluence: 150,
            baseSpeed: 0.5,
            maxSpeed: 2.0,
            particleSize: { min: 1, max: 3 },
            opacity: { min: 0.2, max: 0.8 },
            colors: [
                { h: 220, s: 70, l: 60 }, // Blue
                { h: 260, s: 60, l: 65 }, // Purple
                { h: 280, s: 50, l: 70 }, // Light purple
                { h: 240, s: 80, l: 55 }  // Deep blue
            ]
        };

        this.init();
        this.resize();
    }

    /**
     * Initialize the particle system
     */
    init() {
        this.particles = [];
        this.createParticles();
    }

    /**
     * Create initial particles
     */
    createParticles() {
        for (let i = 0; i < this.config.maxParticles; i++) {
            this.particles.push(this.createParticle());
        }
    }

    /**
     * Create a single particle
     * @returns {Object} Particle object
     */
    createParticle() {
        const color = this.config.colors[Math.floor(Math.random() * this.config.colors.length)];
        
        return {
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * this.config.baseSpeed,
            vy: (Math.random() - 0.5) * this.config.baseSpeed,
            size: Utils.random(this.config.particleSize.min, this.config.particleSize.max),
            opacity: Utils.random(this.config.opacity.min, this.config.opacity.max),
            baseOpacity: Utils.random(this.config.opacity.min, this.config.opacity.max),
            color: color,
            life: 1.0,
            maxLife: Utils.random(5, 10),
            age: 0,
            mouseDistance: 1000,
            connections: 0
        };
    }

    /**
     * Update particle system
     * @param {number} mouseX - Mouse X position
     * @param {number} mouseY - Mouse Y position
     */
    update(mouseX, mouseY) {
        this.mouseX = mouseX;
        this.mouseY = mouseY;

        // Update particles
        this.updateParticles();
        
        // Update connections
        this.updateConnections();
        
        // Maintain particle count
        this.maintainParticleCount();
    }

    /**
     * Update all particles
     */
    updateParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            
            // Calculate mouse influence
            const dx = this.mouseX - particle.x;
            const dy = this.mouseY - particle.y;
            particle.mouseDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Apply mouse influence
            if (particle.mouseDistance < this.config.mouseInfluence) {
                const force = (this.config.mouseInfluence - particle.mouseDistance) / this.config.mouseInfluence;
                const angle = Math.atan2(dy, dx);
                particle.vx -= Math.cos(angle) * force * 0.02;
                particle.vy -= Math.sin(angle) * force * 0.02;
            }
            
            // Update velocity with damping
            particle.vx *= 0.99;
            particle.vy *= 0.99;
            
            // Limit speed
            const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
            if (speed > this.config.maxSpeed) {
                particle.vx = (particle.vx / speed) * this.config.maxSpeed;
                particle.vy = (particle.vy / speed) * this.config.maxSpeed;
            }
            
            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;
            
            // Wrap around screen edges
            if (particle.x < 0) particle.x = this.canvas.width;
            if (particle.x > this.canvas.width) particle.x = 0;
            if (particle.y < 0) particle.y = this.canvas.height;
            if (particle.y > this.canvas.height) particle.y = 0;
            
            // Update life
            particle.age += 0.016; // Assuming 60 FPS
            particle.life = 1.0 - (particle.age / particle.maxLife);
            
            // Update opacity based on mouse proximity and connections
            const mouseProximity = 1.0 - Math.min(particle.mouseDistance / this.config.mouseInfluence, 1.0);
            const connectionBonus = Math.min(particle.connections * 0.1, 0.3);
            particle.opacity = particle.baseOpacity + mouseProximity * 0.3 + connectionBonus;
            particle.opacity = Utils.clamp(particle.opacity, 0.1, 1.0);
            
            // Remove dead particles
            if (particle.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }

    /**
     * Update particle connections
     */
    updateConnections() {
        this.connections = [];
        
        // Reset connection counts
        this.particles.forEach(particle => {
            particle.connections = 0;
        });
        
        // Calculate connections
        for (let i = 0; i < this.particles.length; i++) {
            for (let j = i + 1; j < this.particles.length; j++) {
                const p1 = this.particles[i];
                const p2 = this.particles[j];
                
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.config.connectionDistance) {
                    const strength = 1.0 - (distance / this.config.connectionDistance);
                    
                    this.connections.push({
                        p1: p1,
                        p2: p2,
                        distance: distance,
                        strength: strength,
                        opacity: strength * Math.min(p1.opacity, p2.opacity)
                    });
                    
                    p1.connections++;
                    p2.connections++;
                }
            }
        }
    }

    /**
     * Maintain particle count by creating new particles
     */
    maintainParticleCount() {
        while (this.particles.length < this.config.maxParticles) {
            this.particles.push(this.createParticle());
        }
    }

    /**
     * Render the particle system
     */
    render() {
        // Clear canvas with gradient background
        this.renderBackground();
        
        // Render connections
        this.renderConnections();
        
        // Render particles
        this.renderParticles();
    }

    /**
     * Render background gradient
     */
    renderBackground() {
        const gradient = this.ctx.createRadialGradient(
            this.mouseX, this.mouseY, 0,
            this.mouseX, this.mouseY, 400
        );
        
        gradient.addColorStop(0, `hsla(240, 50%, 8%, 1)`);
        gradient.addColorStop(0.5, `hsla(260, 40%, 5%, 1)`);
        gradient.addColorStop(1, 'hsla(280, 30%, 2%, 1)');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Render particle connections
     */
    renderConnections() {
        this.ctx.strokeStyle = 'rgba(138, 107, 255, 0.3)';
        this.ctx.lineWidth = 1;
        
        for (const connection of this.connections) {
            if (connection.opacity > 0.05) {
                // Create gradient for connection line
                const gradient = this.ctx.createLinearGradient(
                    connection.p1.x, connection.p1.y,
                    connection.p2.x, connection.p2.y
                );
                
                const color1 = connection.p1.color;
                const color2 = connection.p2.color;
                
                gradient.addColorStop(0, `hsla(${color1.h}, ${color1.s}%, ${color1.l}%, ${connection.opacity})`);
                gradient.addColorStop(1, `hsla(${color2.h}, ${color2.s}%, ${color2.l}%, ${connection.opacity})`);
                
                this.ctx.strokeStyle = gradient;
                this.ctx.lineWidth = connection.strength * 2;
                
                this.ctx.beginPath();
                this.ctx.moveTo(connection.p1.x, connection.p1.y);
                this.ctx.lineTo(connection.p2.x, connection.p2.y);
                this.ctx.stroke();
            }
        }
    }

    /**
     * Render particles
     */
    renderParticles() {
        for (const particle of this.particles) {
            if (particle.opacity > 0.05) {
                const color = particle.color;
                
                // Create radial gradient for particle
                const gradient = this.ctx.createRadialGradient(
                    particle.x, particle.y, 0,
                    particle.x, particle.y, particle.size * 3
                );
                
                gradient.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${particle.opacity})`);
                gradient.addColorStop(0.5, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${particle.opacity * 0.5})`);
                gradient.addColorStop(1, `hsla(${color.h}, ${color.s}%, ${color.l}%, 0)`);
                
                this.ctx.fillStyle = gradient;
                
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw core
                this.ctx.fillStyle = `hsla(${color.h}, ${color.s}%, ${color.l + 20}%, ${particle.opacity})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Resize canvas and update particle positions
     */
    resize() {
        Utils.resizeCanvas(this.canvas);
        
        // Redistribute particles if canvas size changed significantly
        const area = this.canvas.width * this.canvas.height;
        const targetParticleCount = Math.min(
            Math.floor(area / 20000), 
            this.config.maxParticles
        );
        
        // Adjust particle positions to new canvas size
        this.particles.forEach(particle => {
            particle.x = Math.min(particle.x, this.canvas.width);
            particle.y = Math.min(particle.y, this.canvas.height);
        });
        
        // Adjust particle count based on canvas size
        if (targetParticleCount < this.particles.length) {
            this.particles.splice(targetParticleCount);
        }
    }

    /**
     * Add burst effect at position
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} count - Number of particles to create
     */
    addBurst(x, y, count = 5) {
        for (let i = 0; i < count; i++) {
            const particle = this.createParticle();
            particle.x = x + Utils.random(-20, 20);
            particle.y = y + Utils.random(-20, 20);
            particle.vx = Utils.random(-2, 2);
            particle.vy = Utils.random(-2, 2);
            particle.opacity = 1.0;
            particle.life = 1.0;
            this.particles.push(particle);
        }
    }

    /**
     * Get particle system statistics
     * @returns {Object} Statistics object
     */
    getStats() {
        return {
            particleCount: this.particles.length,
            connectionCount: this.connections.length,
            averageConnections: this.particles.length > 0 ? 
                this.particles.reduce((sum, p) => sum + p.connections, 0) / this.particles.length : 0
        };
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ParticleSystem;
}/**
 * Performance monitoring system for raytracing applications
 */
class PerformanceMonitor {
    constructor() {
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        this.averageFPS = 0;
        this.minFPS = Infinity;
        this.maxFPS = 0;
        this.frameHistory = [];
        this.maxHistoryLength = 60; // Track last 60 frames
        
        this.rayCount = 0;
        this.triangleCount = 0;
        this.memoryUsage = { used: 0, total: 0 };
        
        this.isMonitoring = false;
        this.onUpdate = null; // Callback for performance updates
    }

    /**
     * Start monitoring performance
     */
    start() {
        this.isMonitoring = true;
        this.lastTime = performance.now();
        this.frameCount = 0;
        this.frameHistory = [];
        console.log('Performance monitoring started');
    }

    /**
     * Stop monitoring performance
     */
    stop() {
        this.isMonitoring = false;
        console.log('Performance monitoring stopped');
    }

    /**
     * Update performance metrics
     * Should be called once per frame
     */
    update() {
        if (!this.isMonitoring) return;

        const currentTime = performance.now();
        const deltaTime = currentTime - this.lastTime;
        
        this.frameCount++;
        
        // Calculate current FPS
        this.fps = Utils.calculateFPS(deltaTime);
        
        // Update frame history
        this.frameHistory.push(this.fps);
        if (this.frameHistory.length > this.maxHistoryLength) {
            this.frameHistory.shift();
        }
        
        // Calculate statistics
        this.updateStatistics();
        
        // Update memory usage if available
        this.updateMemoryUsage();
        
        // Call update callback if provided
        if (this.onUpdate) {
            this.onUpdate(this.getMetrics());
        }
        
        this.lastTime = currentTime;
    }

    /**
     * Update FPS statistics
     */
    updateStatistics() {
        if (this.frameHistory.length === 0) return;
        
        // Calculate average FPS
        const sum = this.frameHistory.reduce((a, b) => a + b, 0);
        this.averageFPS = Math.round(sum / this.frameHistory.length);
        
        // Update min/max FPS
        this.minFPS = Math.min(this.minFPS, this.fps);
        this.maxFPS = Math.max(this.maxFPS, this.fps);
    }

    /**
     * Update memory usage information
     */
    updateMemoryUsage() {
        const memInfo = Utils.getMemoryUsage();
        if (memInfo) {
            this.memoryUsage = memInfo;
        }
    }

    /**
     * Set ray count for current frame
     * @param {number} count - Number of rays traced
     */
    setRayCount(count) {
        this.rayCount = count;
    }

    /**
     * Set triangle count for current frame
     * @param {number} count - Number of triangles processed
     */
    setTriangleCount(count) {
        this.triangleCount = count;
    }

    /**
     * Get current performance metrics
     * @returns {Object} Performance metrics object
     */
    getMetrics() {
        return {
            fps: this.fps,
            averageFPS: this.averageFPS,
            minFPS: this.minFPS === Infinity ? 0 : this.minFPS,
            maxFPS: this.maxFPS,
            frameCount: this.frameCount,
            rayCount: this.rayCount,
            triangleCount: this.triangleCount,
            memoryUsage: this.memoryUsage
        };
    }

    /**
     * Get formatted performance string for display
     * @param {string} type - Type of display ('simple' or 'detailed')
     * @returns {string} Formatted performance string
     */
    getDisplayString(type = 'simple') {
        const metrics = this.getMetrics();
        
        switch (type) {
            case 'simple':
                return `FPS: ${metrics.fps} | Rayons: ${Utils.formatNumber(metrics.rayCount)}`;
                
            case 'detailed':
                return `FPS: ${metrics.fps} (avg: ${metrics.averageFPS}, min: ${metrics.minFPS}, max: ${metrics.maxFPS}) | ` +
                       `Rayons: ${Utils.formatNumber(metrics.rayCount)} | ` +
                       `Triangles: ${Utils.formatNumber(metrics.triangleCount)} | ` +
                       `Mémoire: ${metrics.memoryUsage.used}MB`;
                       
            case 'fps-only':
                return `FPS: ${metrics.fps}`;
                
            case 'rays-only':
                return `Rayons: ${Utils.formatNumber(metrics.rayCount)}`;
                
            default:
                return this.getDisplayString('simple');
        }
    }

    /**
     * Check if performance is poor
     * @returns {boolean} True if performance is below acceptable threshold
     */
    isPoorPerformance() {
        return this.averageFPS < 30 && this.frameHistory.length > 30;
    }

    /**
     * Get performance level
     * @returns {string} Performance level ('excellent', 'good', 'fair', 'poor')
     */
    getPerformanceLevel() {
        if (this.averageFPS >= 55) return 'excellent';
        if (this.averageFPS >= 45) return 'good';
        if (this.averageFPS >= 30) return 'fair';
        return 'poor';
    }

    /**
     * Get suggested quality settings based on performance
     * @returns {Object} Suggested quality settings
     */
    getSuggestedQuality() {
        const level = this.getPerformanceLevel();
        
        switch (level) {
            case 'excellent':
                return {
                    resolutionScale: 1.0,
                    raySteps: 50,
                    shadowQuality: 'high',
                    reflectionBounces: 3
                };
                
            case 'good':
                return {
                    resolutionScale: 0.8,
                    raySteps: 35,
                    shadowQuality: 'medium',
                    reflectionBounces: 2
                };
                
            case 'fair':
                return {
                    resolutionScale: 0.6,
                    raySteps: 25,
                    shadowQuality: 'low',
                    reflectionBounces: 1
                };
                
            case 'poor':
                return {
                    resolutionScale: 0.4,
                    raySteps: 15,
                    shadowQuality: 'off',
                    reflectionBounces: 0
                };
                
            default:
                return this.getSuggestedQuality();
        }
    }

    /**
     * Reset all performance statistics
     */
    reset() {
        this.frameCount = 0;
        this.fps = 0;
        this.averageFPS = 0;
        this.minFPS = Infinity;
        this.maxFPS = 0;
        this.frameHistory = [];
        this.rayCount = 0;
        this.triangleCount = 0;
        this.lastTime = performance.now();
    }

    /**
     * Export performance data for analysis
     * @returns {Object} Performance data object
     */
    exportData() {
        return {
            timestamp: Date.now(),
            sessionDuration: performance.now() - this.lastTime,
            metrics: this.getMetrics(),
            frameHistory: [...this.frameHistory],
            performanceLevel: this.getPerformanceLevel(),
            suggestedQuality: this.getSuggestedQuality()
        };
    }

    /**
     * Log performance summary to console
     */
    logSummary() {
        const metrics = this.getMetrics();
        const level = this.getPerformanceLevel();
        
        console.group('Performance Summary');
        console.log(`Performance Level: ${level}`);
        console.log(`Current FPS: ${metrics.fps}`);
        console.log(`Average FPS: ${metrics.averageFPS}`);
        console.log(`FPS Range: ${metrics.minFPS} - ${metrics.maxFPS}`);
        console.log(`Total Frames: ${metrics.frameCount}`);
        console.log(`Rays per Frame: ${Utils.formatNumber(metrics.rayCount)}`);
        console.log(`Memory Usage: ${metrics.memoryUsage.used}MB / ${metrics.memoryUsage.total}MB`);
        console.groupEnd();
    }

    /**
     * Set callback for performance updates
     * @param {Function} callback - Function to call on performance update
     */
    setUpdateCallback(callback) {
        this.onUpdate = callback;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PerformanceMonitor;
}/**
 * Base raytracing engine for WebGL-based simulations
 */
class RaytracingEngine {
    constructor() {
        this.canvas = null;
        this.gl = null;
        this.program = null;
        this.performanceElement = null;
        this.isRunning = false;
        this.animationId = null;
        
        // Performance tracking
        this.performanceMonitor = new PerformanceMonitor();
        this.rayCount = 0;
        
        // Quality settings
        this.quality = {
            resolutionScale: 0.8,
            raySteps: 30,
            shadowQuality: 'medium',
            reflectionBounces: 2
        };
        
        // Time tracking
        this.startTime = 0;
        this.currentTime = 0;
        
        // WebGL resources
        this.resources = {
            buffers: [],
            textures: [],
            framebuffers: []
        };
    }

    /**
     * Initialize the raytracing engine
     * @param {string} canvasId - Canvas element ID
     * @param {string} perfId - Performance display element ID
     */
    init(canvasId, perfId) {
        try {
            this.canvas = document.getElementById(canvasId);
            this.performanceElement = document.getElementById(perfId);
            
            if (!this.canvas) {
                throw new Error(`Canvas element '${canvasId}' not found`);
            }

            // Get WebGL context
            this.gl = Utils.getWebGLContext(this.canvas);
            if (!this.gl) {
                throw new Error('Failed to get WebGL context');
            }

            // Initialize WebGL state
            this.initWebGL();
            
            // Create shader program
            this.createShaderProgram();
            
            // Initialize geometry
            this.initGeometry();
            
            // Set up performance monitoring
            this.setupPerformanceMonitoring();
            
            // Handle canvas resize
            this.setupResizeHandler();
            
            console.log(`${this.constructor.name} initialized successfully`);
            
        } catch (error) {
            console.error(`${this.constructor.name} initialization failed:`, error);
            throw error;
        }
    }

    /**
     * Initialize WebGL state
     */
    initWebGL() {
        const gl = this.gl;
        
        // Set viewport
        gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        
        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        
        // Set clear color
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        
        // Enable blending for transparency
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }

    /**
     * Create shader program (to be overridden by subclasses)
     */
    createShaderProgram() {
        // Base implementation - should be overridden
        const vertexSource = this.getVertexShader();
        const fragmentSource = this.getFragmentShader();
        
        this.program = Utils.createProgram(this.gl, vertexSource, fragmentSource);
        
        if (!this.program) {
            throw new Error('Failed to create shader program');
        }
    }

    /**
     * Get vertex shader source (to be overridden by subclasses)
     * @returns {string} Vertex shader source code
     */
    getVertexShader() {
        return `
            attribute vec2 a_position;
            varying vec2 v_uv;
            
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
    }

    /**
     * Get fragment shader source (to be overridden by subclasses)
     * @returns {string} Fragment shader source code
     */
    getFragmentShader() {
        return `
            precision mediump float;
            varying vec2 v_uv;
            uniform float u_time;
            
            void main() {
                gl_FragColor = vec4(v_uv, sin(u_time), 1.0);
            }
        `;
    }

    /**
     * Initialize geometry (quad for screen-space rendering)
     */
    initGeometry() {
        const gl = this.gl;
        
        // Create full-screen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        this.resources.buffers.push(buffer);
        
        // Set up vertex attributes
        const positionLocation = gl.getAttribLocation(this.program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    }

    /**
     * Setup performance monitoring
     */
    setupPerformanceMonitoring() {
        this.performanceMonitor.setUpdateCallback((metrics) => {
            this.updatePerformanceDisplay(metrics);
        });
    }

    /**
     * Update performance display
     * @param {Object} metrics - Performance metrics
     */
    updatePerformanceDisplay(metrics) {
        if (this.performanceElement) {
            const displayString = this.performanceMonitor.getDisplayString('simple');
            this.performanceElement.textContent = displayString;
        }
    }

    /**
     * Setup canvas resize handler
     */
    setupResizeHandler() {
        const resizeHandler = Utils.debounce(() => {
            this.resize();
        }, 250);
        
        window.addEventListener('resize', resizeHandler);
    }

    /**
     * Resize canvas and update WebGL viewport
     */
    resize() {
        if (!this.canvas || !this.gl) return;
        
        Utils.resizeCanvas(this.canvas, 2);
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        
        // Update any size-dependent uniforms
        this.updateUniforms();
    }

    /**
     * Update shader uniforms (to be overridden by subclasses)
     */
    updateUniforms() {
        const gl = this.gl;
        
        if (this.program) {
            gl.useProgram(this.program);
            
            // Update time
            const timeLocation = gl.getUniformLocation(this.program, 'u_time');
            if (timeLocation) {
                gl.uniform1f(timeLocation, this.currentTime);
            }
            
            // Update resolution
            const resolutionLocation = gl.getUniformLocation(this.program, 'u_resolution');
            if (resolutionLocation) {
                gl.uniform2f(resolutionLocation, this.canvas.width, this.canvas.height);
            }
        }
    }

    /**
     * Start the raytracing animation
     */
    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.startTime = performance.now();
        this.performanceMonitor.start();
        
        this.animate();
        
        console.log(`${this.constructor.name} started`);
    }

    /**
     * Stop the raytracing animation
     */
    stop() {
        if (!this.isRunning) return;
        
        this.isRunning = false;
        this.performanceMonitor.stop();
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        console.log(`${this.constructor.name} stopped`);
    }

    /**
     * Main animation loop
     */
    animate() {
        if (!this.isRunning) return;
        
        // Update time
        this.currentTime = (performance.now() - this.startTime) * 0.001;
        
        // Update performance monitor
        this.performanceMonitor.update();
        this.performanceMonitor.setRayCount(this.rayCount);
        
        // Render frame
        this.render();
        
        // Schedule next frame
        this.animationId = requestAnimationFrame(() => this.animate());
    }

    /**
     * Render a frame (to be overridden by subclasses)
     */
    render() {
        const gl = this.gl;
        
        // Clear the canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        // Use shader program
        gl.useProgram(this.program);
        
        // Update uniforms
        this.updateUniforms();
        
        // Draw full-screen quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        // Update ray count (basic estimation)
        this.rayCount = this.canvas.width * this.canvas.height;
    }

    /**
     * Adjust quality based on performance
     */
    adjustQuality() {
        const suggested = this.performanceMonitor.getSuggestedQuality();
        
        // Apply suggested quality settings
        this.quality = { ...this.quality, ...suggested };
        
        // Resize canvas if resolution scale changed
        if (suggested.resolutionScale !== this.quality.resolutionScale) {
            this.resize();
        }
        
        console.log('Quality adjusted:', this.quality);
    }

    /**
     * Get current quality settings
     * @returns {Object} Quality settings object
     */
    getQuality() {
        return { ...this.quality };
    }

    /**
     * Set quality settings
     * @param {Object} quality - Quality settings to apply
     */
    setQuality(quality) {
        this.quality = { ...this.quality, ...quality };
        this.updateUniforms();
    }

    /**
     * Clean up WebGL resources
     */
    cleanup() {
        if (!this.gl) return;
        
        // Stop animation
        this.stop();
        
        // Delete buffers
        this.resources.buffers.forEach(buffer => {
            this.gl.deleteBuffer(buffer);
        });
        
        // Delete textures
        this.resources.textures.forEach(texture => {
            this.gl.deleteTexture(texture);
        });
        
        // Delete framebuffers
        this.resources.framebuffers.forEach(fb => {
            this.gl.deleteFramebuffer(fb.framebuffer);
            this.gl.deleteTexture(fb.texture);
        });
        
        // Delete program
        if (this.program) {
            this.gl.deleteProgram(this.program);
        }
        
        // Clear resource arrays
        this.resources.buffers = [];
        this.resources.textures = [];
        this.resources.framebuffers = [];
        
        console.log(`${this.constructor.name} resources cleaned up`);
    }

    /**
     * Get engine statistics
     * @returns {Object} Statistics object
     */
    getStats() {
        return {
            isRunning: this.isRunning,
            currentTime: this.currentTime,
            quality: this.getQuality(),
            performance: this.performanceMonitor.getMetrics(),
            resources: {
                buffers: this.resources.buffers.length,
                textures: this.resources.textures.length,
                framebuffers: this.resources.framebuffers.length
            }
        };
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = RaytracingEngine;
}/**
 * Utility functions for the raytracing portfolio
 */
class Utils {
    /**
     * Check if WebGL is supported
     * @returns {boolean} True if WebGL is supported
     */
    static checkWebGLSupport() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            return !!(gl && gl instanceof WebGLRenderingContext);
        } catch (e) {
            return false;
        }
    }

    /**
     * Get WebGL context with error handling
     * @param {HTMLCanvasElement} canvas - Canvas element
     * @returns {WebGLRenderingContext|null} WebGL context or null
     */
    static getWebGLContext(canvas) {
        try {
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                throw new Error('WebGL context could not be created');
            }

            // Enable necessary extensions
            const extensions = [
                'OES_texture_float',
                'OES_texture_float_linear',
                'WEBGL_depth_texture'
            ];

            extensions.forEach(ext => {
                const extension = gl.getExtension(ext);
                if (!extension) {
                    console.warn(`WebGL extension ${ext} not supported`);
                }
            });

            return gl;
        } catch (error) {
            console.error('WebGL context creation failed:', error);
            return null;
        }
    }

    /**
     * Create and compile a shader
     * @param {WebGLRenderingContext} gl - WebGL context
     * @param {number} type - Shader type (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER)
     * @param {string} source - Shader source code
     * @returns {WebGLShader|null} Compiled shader or null
     */
    static createShader(gl, type, source) {
        try {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(`Shader compilation failed: ${error}`);
            }

            return shader;
        } catch (error) {
            console.error('Shader creation failed:', error);
            return null;
        }
    }

    /**
     * Create and link a shader program
     * @param {WebGLRenderingContext} gl - WebGL context
     * @param {string} vertexSource - Vertex shader source
     * @param {string} fragmentSource - Fragment shader source
     * @returns {WebGLProgram|null} Linked program or null
     */
    static createProgram(gl, vertexSource, fragmentSource) {
        try {
            const vertexShader = this.createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = this.createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(program);
                gl.deleteProgram(program);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                throw new Error(`Program linking failed: ${error}`);
            }

            // Clean up shaders after linking
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);

            return program;
        } catch (error) {
            console.error('Program creation failed:', error);
            return null;
        }
    }

    /**
     * Create a texture from image data
     * @param {WebGLRenderingContext} gl - WebGL context
     * @param {number} width - Texture width
     * @param {number} height - Texture height
     * @param {ArrayBufferView} data - Texture data
     * @param {number} format - Texture format (default: gl.RGBA)
     * @param {number} type - Data type (default: gl.UNSIGNED_BYTE)
     * @returns {WebGLTexture|null} Created texture or null
     */
    static createTexture(gl, width, height, data = null, format = null, type = null) {
        try {
            format = format || gl.RGBA;
            type = type || gl.UNSIGNED_BYTE;

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, data);

            // Set texture parameters
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindTexture(gl.TEXTURE_2D, null);

            return texture;
        } catch (error) {
            console.error('Texture creation failed:', error);
            return null;
        }
    }

    /**
     * Clamp a value between min and max
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Clamped value
     */
    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    /**
     * Linear interpolation between two values
     * @param {number} a - Start value
     * @param {number} b - End value
     * @param {number} t - Interpolation factor (0-1)
     * @returns {number} Interpolated value
     */
    static lerp(a, b, t) {
        return a + (b - a) * t;
    }

    /**
     * Smooth step function
     * @param {number} edge0 - Lower edge
     * @param {number} edge1 - Upper edge
     * @param {number} x - Input value
     * @returns {number} Smooth step result
     */
    static smoothstep(edge0, edge1, x) {
        const t = this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        return t * t * (3.0 - 2.0 * t);
    }

    /**
     * Generate random number between min and max
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random value
     */
    static random(min = 0, max = 1) {
        return min + Math.random() * (max - min);
    }

    /**
     * Convert degrees to radians
     * @param {number} degrees - Angle in degrees
     * @returns {number} Angle in radians
     */
    static degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    /**
     * Convert radians to degrees
     * @param {number} radians - Angle in radians
     * @returns {number} Angle in degrees
     */
    static radToDeg(radians) {
        return radians * 180 / Math.PI;
    }

    /**
     * Check if device is mobile
     * @returns {boolean} True if mobile device
     */
    static isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    /**
     * Get device pixel ratio for high DPI displays
     * @returns {number} Device pixel ratio
     */
    static getPixelRatio() {
        return window.devicePixelRatio || 1;
    }

    /**
     * Resize canvas to match display size
     * @param {HTMLCanvasElement} canvas - Canvas element
     * @param {number} maxPixelRatio - Maximum pixel ratio to use
     */
    static resizeCanvas(canvas, maxPixelRatio = 2) {
        const pixelRatio = Math.min(this.getPixelRatio(), maxPixelRatio);
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;

        const width = Math.floor(displayWidth * pixelRatio);
        const height = Math.floor(displayHeight * pixelRatio);

        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }

    /**
     * Create a frame buffer object
     * @param {WebGLRenderingContext} gl - WebGL context
     * @param {number} width - Buffer width
     * @param {number} height - Buffer height
     * @returns {Object|null} Frame buffer object with texture and framebuffer
     */
    static createFrameBuffer(gl, width, height) {
        try {
            const texture = this.createTexture(gl, width, height);
            if (!texture) return null;

            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (status !== gl.FRAMEBUFFER_COMPLETE) {
                throw new Error(`Framebuffer incomplete: ${status}`);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return { framebuffer, texture };
        } catch (error) {
            console.error('Framebuffer creation failed:', error);
            return null;
        }
    }

    /**
     * Debounce function calls
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in milliseconds
     * @returns {Function} Debounced function
     */
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    /**
     * Throttle function calls
     * @param {Function} func - Function to throttle
     * @param {number} limit - Time limit in milliseconds
     * @returns {Function} Throttled function
     */
    static throttle(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    /**
     * Format number with suffix (K, M, B)
     * @param {number} num - Number to format
     * @returns {string} Formatted number string
     */
    static formatNumber(num) {
        if (num >= 1000000000) {
            return (num / 1000000000).toFixed(1) + 'B';
        }
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'M';
        }
        if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'K';
        }
        return num.toString();
    }

    /**
     * Calculate FPS from frame time
     * @param {number} deltaTime - Frame time in milliseconds
     * @returns {number} FPS value
     */
    static calculateFPS(deltaTime) {
        return Math.round(1000 / deltaTime);
    }

    /**
     * Memory usage information (if available)
     * @returns {Object} Memory usage object
     */
    static getMemoryUsage() {
        if (performance.memory) {
            return {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            };
        }
        return null;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Utils;
}* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #000;
    min-height: 100vh;
    color: white;
    overflow-x: hidden;
    position: relative;
    cursor: none;
}

.custom-cursor {
    position: fixed;
    width: 20px;
    height: 20px;
    background: radial-gradient(circle, rgba(138, 107, 255, 0.8) 0%, transparent 70%);
    border-radius: 50%;
    pointer-events: none;
    z-index: 10000;
    transition: transform 0.1s ease-out;
    box-shadow: 0 0 20px rgba(138, 107, 255, 0.6);
}

.cursor-trail {
    position: fixed;
    width: 6px;
    height: 6px;
    background: rgba(138, 107, 255, 0.4);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    transition: all 0.4s ease-out;
}

.interactive-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 50% 50%, 
        rgba(13, 13, 35, 1) 0%, 
        rgba(8, 8, 20, 1) 30%, 
        rgba(2, 2, 8, 1) 100%);
    z-index: 1;
}

.bg-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
    pointer-events: none;
}

.back-button {
    position: fixed;
    top: 30px;
    left: 30px;
    padding: 15px 30px;
    background: rgba(138, 107, 255, 0.15);
    border-radius: 30px;
    color: white;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex;
    align-items: center;
    gap: 12px;
    border: 2px solid rgba(138, 107, 255, 0.3);
    backdrop-filter: blur(20px);
    z-index: 1000;
    font-size: 1.1rem;
}

.back-button:hover {
    background: rgba(138, 107, 255, 0.4);
    transform: translateY(-5px) scale(1.05);
    box-shadow: 0 15px 40px rgba(138, 107, 255, 0.4);
    border-color: rgba(138, 107, 255, 0.8);
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 120px 40px 40px;
    position: relative;
    z-index: 10;
}

.header {
    text-align: center;
    margin-bottom: 80px;
    position: relative;
}

.title {
    font-size: 5rem;
    margin-bottom: 20px;
    background: linear-gradient(45deg, 
        #8a6bff 0%, 
        #ff7eb9 25%, 
        #4facfe 50%, 
        #00f2fe 75%, 
        #8a6bff 100%);
    background-size: 400% 400%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradientShift 4s ease-in-out infinite;
    font-weight: 900;
    text-shadow: 0 0 50px rgba(138, 107, 255, 0.7);
    letter-spacing: -2px;
}

@keyframes gradientShift {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.subtitle {
    font-size: 1.6rem;
    opacity: 0.9;
    max-width: 800px;
    margin: 0 auto;
    line-height: 1.8;
    color: #a0a0ff;
    text-shadow: 0 0 20px rgba(160, 160, 255, 0.3);
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
    gap: 50px;
    margin-top: 80px;
}

.game-card {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 30px;
    padding: 0;
    position: relative;
    overflow: hidden;
    border: 2px solid rgba(138, 107, 255, 0.2);
    backdrop-filter: blur(30px);
    transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    height: 600px;
    cursor: pointer;
}

.game-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, 
        rgba(138, 107, 255, 0.1) 0%, 
        rgba(255, 126, 185, 0.1) 50%, 
        rgba(79, 172, 254, 0.1) 100%);
    opacity: 0;
    transition: opacity 0.6s ease;
    z-index: 1;
}

.game-card:hover::before {
    opacity: 1;
}

.game-card:hover {
    transform: translateY(-20px) rotateX(8deg) scale(1.02);
    box-shadow: 0 40px 80px rgba(138, 107, 255, 0.4);
    border-color: rgba(138, 107, 255, 0.8);
}

.game-canvas {
    width: 100%;
    height: 450px;
    border-radius: 25px 25px 0 0;
    background: #000;
    position: relative;
    z-index: 2;
    display: block;
}

.game-info {
    padding: 30px;
    background: rgba(0, 0, 0, 0.4);
    position: relative;
    z-index: 2;
}

.game-title {
    font-size: 2rem;
    font-weight: 800;
    margin-bottom: 10px;
    background: linear-gradient(45deg, #8a6bff, #ff7eb9);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.game-desc {
    font-size: 1.1rem;
    opacity: 0.9;
    line-height: 1.6;
    color: #c0c0ff;
}

.performance-info {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(0, 0, 0, 0.7);
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 0.9rem;
    color: #4facfe;
    backdrop-filter: blur(10px);
    z-index: 100;
    font-family: 'Courier New', monospace;
}

.ambient-light {
    position: fixed;
    width: 300px;
    height: 300px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(138, 107, 255, 0.15) 0%, transparent 70%);
    pointer-events: none;
    z-index: 3;
    transition: all 0.3s ease-out;
}

.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
    backdrop-filter: blur(5px);
    border-radius: 30px;
}

.loading-spinner {
    border: 5px solid rgba(138, 107, 255, 0.2);
    border-top: 5px solid #8a6bff;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.error-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 69, 69, 0.9);
    color: white;
    padding: 20px 30px;
    border-radius: 15px;
    font-size: 1.1rem;
    z-index: 10001;
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 69, 69, 0.5);
    display: flex;
    align-items: center;
    gap: 10px;
    max-width: 600px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(255, 69, 69, 0.3);
}

.error-message i {
    font-size: 1.3rem;
}

@media (max-width: 768px) {
    .games-grid {
        grid-template-columns: 1fr;
        gap: 40px;
    }
    
    .title {
        font-size: 3.5rem;
    }
    
    .container {
        padding: 100px 20px 20px;
    }

    .game-card {
        height: 500px;
    }
    
    .game-canvas {
        height: 350px;
    }

    .back-button {
        top: 20px;
        left: 20px;
        padding: 12px 20px;
        font-size: 1rem;
    }

    .performance-info {
        font-size: 0.8rem;
        padding: 6px 12px;
    }

    .error-message {
        margin: 0 20px;
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .title {
        font-size: 2.8rem;
    }
    
    .subtitle {
        font-size: 1.3rem;
    }
    
    .games-grid {
        grid-template-columns: 1fr;
        gap: 30px;
        margin-top: 60px;
    }
    
    .game-card {
        height: 450px;
    }
    
    .game-canvas {
        height: 300px;
    }
    
    .container {
        padding: 80px 15px 20px;
    }
}

/* High DPI display optimizations */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    .game-canvas {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
    }
}

/* Performance optimizations for animations */
.game-card,
.back-button,
.cursor-trail {
    will-change: transform;
}

.title {
    will-change: background-position;
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
    .title {
        animation: none;
        background: linear-gradient(45deg, #8a6bff, #ff7eb9);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .game-card {
        transition: none;
    }
    
    .back-button {
        transition: background-color 0.3s ease;
    }
    
    .loading-spinner {
        animation: none;
        border: 5px solid #8a6bff;
    }
}<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hachem Lamrini - Portfolio avec Mode Jour/Nuit</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(45deg, #ff6b6b, #ee5a24);
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.18);
            --text-light: rgba(255, 255, 255, 0.9);
            --text-dark: #333;
            --card-bg: rgba(255, 255, 255, 0.85);
            --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --shadow-sm: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 10px 20px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 15px 30px rgba(0, 0, 0, 0.2);
            --blur-sm: blur(8px);
            --blur-md: blur(15px);
            --blur-lg: blur(25px);
            --violet-light: #8a6bff;
            --violet-medium: #6a4bce;
            --violet-dark: #4d2fa8;
            --violet-accent: #b19dff;
            --pink-accent: #ff7eb9;
            --bg-gradient: linear-gradient(135deg, #2a0845 0%, #1a1a2e 100%);
            --header-bg: rgba(255, 255, 255, 0.08);
            --header-border: rgba(255, 255, 255, 0.18);
            --cursor-color: rgba(138, 107, 255, 0.7);
            --cursor-active: rgba(255, 126, 185, 0.8);
            --cursor-clicked: rgba(255, 255, 255, 0.9);
            --cursor-follower: rgba(138, 107, 255, 0.4);
            --section-bg: rgba(255, 255, 255, 0.85);
            --section-border: rgba(255, 255, 255, 0.3);
            --logo-color: white;
            --nav-link-color: white;
            --nav-link-hover: rgba(255, 255, 255, 0.15);
            --hero-color: white;
            --contact-bg: var(--primary-gradient);
            --contact-text: white;
            --contact-item-bg: var(--glass-bg);
            --contact-item-border: var(--glass-border);
            --modal-bg: rgba(30, 30, 40, 0.95);
            --modal-header: var(--primary-gradient);
            --modal-close: white;
            --game-btn-bg: var(--glass-bg);
            --game-btn-border: rgba(255, 255, 255, 0.2);
            --game-btn-hover: rgba(138, 107, 255, 0.3);
        }

        /* Mode jour */
        body.light-mode {
            --primary-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --secondary-gradient: linear-gradient(45deg, #ff9a9e, #fad0c4);
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-light: #333;
            --text-dark: #333;
            --card-bg: rgba(255, 255, 255, 0.95);
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --header-bg: rgba(255, 255, 255, 0.7);
            --header-border: rgba(0, 0, 0, 0.1);
            --cursor-color: rgba(79, 172, 254, 0.7);
            --cursor-active: rgba(255, 154, 158, 0.8);
            --cursor-clicked: rgba(0, 0, 0, 0.9);
            --cursor-follower: rgba(79, 172, 254, 0.4);
            --section-bg: rgba(255, 255, 255, 0.95);
            --section-border: rgba(0, 0, 0, 0.1);
            --logo-color: #333;
            --nav-link-color: #333;
            --nav-link-hover: rgba(0, 0, 0, 0.05);
            --hero-color: #333;
            --contact-bg: var(--primary-gradient);
            --contact-text: #333;
            --contact-item-bg: rgba(255, 255, 255, 0.6);
            --contact-item-border: rgba(0, 0, 0, 0.1);
            --modal-bg: rgba(255, 255, 255, 0.95);
            --modal-header: var(--primary-gradient);
            --modal-close: #333;
            --game-btn-bg: rgba(255, 255, 255, 0.7);
            --game-btn-border: rgba(0, 0, 0, 0.1);
            --game-btn-hover: rgba(79, 172, 254, 0.3);
        }

        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--text-light);
            min-height: 100vh;
            overflow-x: hidden;
            background-attachment: fixed;
            background: var(--bg-gradient);
            transition: background 1s ease, color 0.5s ease;
        }

        /* Preloader */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-gradient);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .loader {
            width: 100px;
            height: 100px;
            position: relative;
            margin-bottom: 2rem;
        }

        .loader-inner {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--violet-light);
            animation: spin 1.5s infinite linear;
        }

        .loader-inner:nth-child(1) {
            animation-delay: 0.1s;
            border-top-color: var(--violet-medium);
        }

        .loader-inner:nth-child(2) {
            animation-delay: 0.2s;
            border-top-color: var(--violet-dark);
        }

        .loader-inner:nth-child(3) {
            animation-delay: 0.3s;
            border-top-color: var(--violet-accent);
        }

        .loader-text {
            font-size: 1.5rem;
            color: var(--text-light);
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .preloader-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .preloader-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--violet-light);
            box-shadow: 0 0 15px var(--violet-light);
            animation: float 8s infinite ease-in-out;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes float {
            0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
            50% { transform: translate(calc(100vw * var(--tx)), calc(100vh * var(--ty))) scale(1.5); opacity: 1; }
            100% { transform: translate(calc(200vw * var(--tx)), calc(200vh * var(--ty))) scale(1); opacity: 0; }
        }

        /* Canvas pour le réseau neuronal */
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Système de curseur amélioré */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--cursor-color);
            box-shadow: 0 0 15px var(--cursor-color);
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: 
                width 0.2s ease, 
                height 0.2s ease,
                background 0.3s ease,
                border 0.3s ease;
            mix-blend-mode: difference;
        }

        .cursor-follower {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid var(--cursor-follower);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9998;
            transition: 
                all 0.6s cubic-bezier(0.15, 0.95, 0.75, 0.95),
                width 0.3s ease,
                height 0.3s ease,
                border 0.3s ease;
            mix-blend-mode: difference;
        }

        .cursor.active {
            width: 40px;
            height: 40px;
            background: var(--cursor-active);
            box-shadow: 0 0 20px var(--cursor-active);
        }

        .cursor.clicked {
            width: 15px;
            height: 15px;
            background: var(--cursor-clicked);
            box-shadow: 0 0 25px var(--cursor-clicked);
        }

        .cursor-follower.expanded {
            transform: translate(-50%, -50%) scale(1.5);
            border-width: 1px;
            opacity: 0.7;
        }

        .cursor-follower.clicked {
            transform: translate(-50%, -50%) scale(0.8);
            border-color: var(--cursor-active);
        }

        .cursor-text {
            position: fixed;
            pointer-events: none;
            z-index: 9997;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            text-shadow: 0 0 10px var(--cursor-active);
            white-space: nowrap;
            transform: translate(-50%, -50%) scale(0.8);
        }

        .cursor-particle {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9997;
            transform: translate(-50%, -50%);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Floating particles background */
        body::before {
            content: '';
            position: fixed;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(3px 3px at 10% 20%, rgba(138, 107, 255, 0.6), transparent),
                radial-gradient(2.5px 2.5px at 90% 80%, rgba(106, 75, 206, 0.5), transparent),
                radial-gradient(3px 3px at 30% 60%, rgba(77, 47, 168, 0.45), transparent),
                radial-gradient(2px 2px at 70% 40%, rgba(177, 157, 255, 0.55), transparent),
                radial-gradient(2.2px 2.2px at 50% 30%, rgba(255, 126, 185, 0.35), transparent);
            background-repeat: repeat;
            background-size: 300px 200px;
            animation: floatingParticles 20s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        body.light-mode::before {
            background-image: 
                radial-gradient(3px 3px at 10% 20%, rgba(79, 172, 254, 0.4), transparent),
                radial-gradient(2.5px 2.5px at 90% 80%, rgba(0, 242, 254, 0.4), transparent),
                radial-gradient(3px 3px at 30% 60%, rgba(255, 154, 158, 0.3), transparent),
                radial-gradient(2px 2px at 70% 40%, rgba(250, 208, 196, 0.3), transparent),
                radial-gradient(2.2px 2.2px at 50% 30%, rgba(255, 255, 255, 0.4), transparent);
        }

        @keyframes floatingParticles {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-100vh) rotate(360deg); }
        }

        /* Header & Navigation */
        header {
            background: var(--header-bg);
            backdrop-filter: var(--blur-md);
            border-bottom: 1px solid var(--header-border);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            transform: translateY(0);
        }

        header.scrolled {
            transform: translateY(-5px);
            backdrop-filter: var(--blur-lg);
            box-shadow: var(--shadow-md);
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.2rem 0;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--logo-color);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: logoPulse 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: logoRipple 3s ease-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes logoRipple {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.8); opacity: 0; }
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 2.5rem;
        }

        .nav-links a {
            color: var(--nav-link-color);
            text-decoration: none;
            font-weight: 600;
            transition: var(--transition);
            padding: 0.7rem 1.5rem;
            border-radius: 30px;
            position: relative;
            overflow: hidden;
            font-size: 1.05rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-links a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--nav-link-hover);
            transition: left 0.5s ease;
            z-index: -1;
        }

        .nav-links a:hover {
            background: var(--nav-link-hover);
            transform: translateY(-3px);
            box-shadow: var(--shadow-sm);
        }

        .nav-links a:hover::before {
            left: 100%;
        }

        .nav-links li {
            animation: slideInFromTop 0.6s ease forwards;
            animation-delay: calc(var(--delay, 0) * 0.1s);
            opacity: 0;
        }

        .nav-links li:nth-child(1) { --delay: 1; }
        .nav-links li:nth-child(2) { --delay: 2; }
        .nav-links li:nth-child(3) { --delay: 3; }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Mobile Menu */
        .menu-toggle {
            display: none;
            flex-direction: column;
            justify-content: space-around;
            width: 2rem;
            height: 2rem;
            background: transparent;
            border: none;
            cursor: none;
            padding: 0;
            z-index: 10;
        }

        .menu-toggle span {
            width: 2rem;
            height: 0.25rem;
            background: var(--nav-link-color);
            border-radius: 10px;
            transition: var(--transition);
            position: relative;
            transform-origin: center;
        }

        /* Hero Section */
        main {
            margin-top: 90px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .hero {
            text-align: center;
            padding: 6rem 0 4rem;
            color: var(--hero-color);
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.03) 0%, transparent 70%);
            animation: wave 15s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes wave {
            0%, 100% { transform: translateX(-50%) translateY(-50%) rotate(0deg); }
            50% { transform: translateX(-50%) translateY(-50%) rotate(180deg); }
        }

        .hero h1 {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            font-weight: 800;
            letter-spacing: -0.5px;
            line-height: 1.1;
            overflow: hidden;
            border-right: .15em solid var(--violet-light);
            white-space: nowrap;
            margin: 0 auto;
            max-width: max-content;
            animation: 
                typing 1.8s steps(30, end),
                blink-caret .75s step-end infinite;
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: var(--violet-light); }
        }

        .hero p {
            font-size: 1.5rem;
            margin: 2rem auto 3rem;
            opacity: 0.9;
            max-width: 700px;
            animation: fadeInUp 1s ease 2s both;
            font-weight: 300;
        }

        .cta-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: var(--secondary-gradient);
            color: white;
            padding: 1.2rem 2.5rem;
            text-decoration: none;
            border-radius: 60px;
            font-weight: 700;
            transition: var(--transition);
            box-shadow: var(--shadow-md);
            animation: fadeInUp 1s ease 2.5s both;
            font-size: 1.1rem;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .cta-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.7s ease;
            z-index: -1;
        }

        .cta-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }

        .cta-button:hover::before {
            left: 100%;
        }

        /* Section styling */
        .section {
            padding: 5rem 0;
            background: var(--section-bg);
            margin: 3rem 0;
            border-radius: 25px;
            box-shadow: var(--shadow-lg);
            backdrop-filter: var(--blur-sm);
            position: relative;
            overflow: hidden;
            transition: var(--transition);
            border: 1px solid var(--section-border);
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .section.active {
            opacity: 1;
            transform: translateY(0);
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.6s ease;
        }

        .section:hover::before {
            transform: scaleX(1);
        }

        .section h2 {
            text-align: center;
            font-size: 2.8rem;
            margin-bottom: 3.5rem;
            color: var(--text-dark);
            position: relative;
            display: inline-block;
            left: 50%;
            transform: translateX(-50%);
            padding: 0 2rem;
        }

        .section h2::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 5px;
            background: var(--primary-gradient);
            border-radius: 3px;
            transition: var(--transition);
        }

        .section:hover h2::after {
            width: 120px;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.6);
        }

        /* About Section */
        .about-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 4rem;
            align-items: center;
        }

        .profile-img-container {
            position: relative;
            perspective: 1000px;
        }

        .profile-img {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: var(--primary-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4.5rem;
            color: white;
            margin: 0 auto;
            box-shadow: var(--shadow-lg);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .profile-img::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2, #667eea);
            animation: rotate 8s linear infinite;
            z-index: -1;
        }

        body.light-mode .profile-img::before {
            background: linear-gradient(45deg, #4facfe, #00f2fe, #4facfe);
        }

        .profile-img:hover {
            transform: rotateY(20deg) scale(1.05);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .profile-img:hover::after {
            content: '👋';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            animation: waveHand 1s ease;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes waveHand {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            50% { transform: rotate(-10deg); }
            75% { transform: rotate(5deg); }
        }

        .about-text {
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--text-dark);
        }

        .about-text p {
            margin-bottom: 1.5rem;
        }

        /* Projects Section */
        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2.5rem;
            margin-top: 2rem;
        }

        .project-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 2.2rem;
            transition: var(--transition);
            border: 1px solid var(--section-border);
            position: relative;
            overflow: hidden;
            cursor: none;
            backdrop-filter: var(--blur-sm);
            transform-style: preserve-3d;
            box-shadow: var(--shadow-sm);
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .project-card.active {
            opacity: 1;
            transform: translateY(0);
        }

        .project-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s ease;
        }

        .project-card:hover {
            transform: translateY(-15px) rotateX(5deg) rotateY(5deg);
            box-shadow: var(--shadow-lg);
        }

        .project-card:hover::before {
            transform: scaleX(1);
        }

        .project-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: translateX(-100%) translateY(-100%) rotate(45deg);
            transition: transform 0.7s ease;
        }

        .project-card:hover::after {
            transform: translateX(100%) translateY(100%) rotate(45deg);
        }

        .project-card h3 {
            font-size: 1.7rem;
            margin-bottom: 1.5rem;
            color: var(--text-dark);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .project-card p {
            margin-bottom: 1.8rem;
            color: #555;
            min-height: 80px;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .tech-tag {
            background: var(--primary-gradient);
            color: white;
            padding: 0.5rem 1.2rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }

        .tech-tag::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.4s ease;
        }

        .tech-tag:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .tech-tag:hover::before {
            left: 100%;
        }

        .video-container {
            margin: 2rem 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            position: relative;
            transition: var(--transition);
        }

        .video-container:hover {
            transform: scale(1.02);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }

        .video-container video {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 15px;
        }

        .project-links {
            display: flex;
            gap: 1.2rem;
            margin-top: 1rem;
        }

        .project-link {
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            cursor: none;
        }

        .code-link {
            background: #333;
            color: white;
        }

        .fullscreen-btn {
            background: var(--primary-gradient);
            color: white;
        }

        .project-link:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-sm);
        }

        /* Contact Section */
        .contact {
            background: var(--contact-bg);
            color: var(--contact-text);
            text-align: center;
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--blur-sm);
        }

        .contact h2::after {
            background: var(--contact-text);
        }

        .contact-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2.5rem;
            margin-top: 3rem;
        }

        .contact-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            font-size: 1.2rem;
            background: var(--contact-item-bg);
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: var(--blur-sm);
            border: 1px solid var(--contact-item-border);
            transition: var(--transition);
            transform-style: preserve-3d;
            cursor: none;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .contact-item.active {
            opacity: 1;
            transform: translateY(0);
        }

        .contact-item:hover {
            transform: translateY(-10px) rotateX(5deg) rotateY(5deg);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: var(--shadow-md);
        }

        .contact-icon {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: var(--transition);
            animation: swing 3s ease-in-out infinite;
            animation-delay: calc(var(--swing-delay, 0) * 0.2s);
        }

        .contact-item:nth-child(1) .contact-icon { --swing-delay: 0; }
        .contact-item:nth-child(2) .contact-icon { --swing-delay: 1; }
        .contact-item:nth-child(3) .contact-icon { --swing-delay: 2; }

        @keyframes swing {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(8deg); }
            75% { transform: rotate(-8deg); }
        }

        .contact-text {
            font-weight: 500;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.92);
            backdrop-filter: var(--blur-lg);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            position: relative;
            background: var(--modal-bg);
            margin: 2% auto;
            padding: 0;
            width: 90%;
            max-width: 900px;
            border-radius: 25px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4);
            animation: modalSlideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--glass-border);
            backdrop-filter: var(--blur-md);
            transform: translateY(20px);
        }

        @keyframes modalSlideIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            background: var(--modal-header);
            color: white;
            padding: 2.5rem;
            border-radius: 25px 25px 0 0;
            position: relative;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 2.5rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .modal-header p {
            margin: 1rem 0 0 0;
            opacity: 0.9;
            font-size: 1.2rem;
            max-width: 80%;
        }

        .close {
            position: absolute;
            right: 2rem;
            top: 2.5rem;
            color: var(--modal-close);
            font-size: 2.5rem;
            font-weight: bold;
            cursor: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            line-height: 1;
        }

        .close:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
        }

        .modal-body {
            padding: 2.5rem;
        }

        .modal-tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 2rem 0;
        }

        .modal-tech-tag {
            background: var(--primary-gradient);
            color: white;
            padding: 0.7rem 1.5rem;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }

        .modal-details {
            font-size: 1.15rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 2.5rem;
        }

        body.light-mode .modal-details {
            color: rgba(0, 0, 0, 0.85);
        }

        .modal-video {
            margin: 2.5rem 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-lg);
        }

        .modal-video video {
            width: 100%;
            height: auto;
            display: block;
        }

        .modal-actions {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .modal-btn {
            padding: 1.2rem 2.5rem;
            border-radius: 40px;
            text-decoration: none;
            font-weight: bold;
            transition: var(--transition);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: none;
        }

        .modal-code-btn {
            background: #333;
            color: white;
        }

        .modal-code-btn:hover {
            background: #444;
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Game Button */
        .game-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 1.2rem 2.5rem;
            background: var(--primary-gradient);
            color: white;
            border-radius: 60px;
            font-weight: 700;
            text-decoration: none;
            box-shadow: var(--shadow-md);
            cursor: none;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            z-index: 100;
            transition: var(--transition);
            border: 2px solid var(--glass-border);
            backdrop-filter: var(--blur-sm);
            animation: pulseGlow 2.5s infinite;
        }

        .game-button span {
            position: relative;
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.7s ease;
            z-index: 1;
        }

        .game-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        }

        .game-button:hover::before {
            left: 100%;
        }

        .button-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(138, 107, 255, 0.7);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(138, 107, 255, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(138, 107, 255, 0);
            }
        }

        /* Game Experience */
        #gameExperience {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            z-index: 5000;
            display: none;
            opacity: 0;
            transition: opacity 1.5s cubic-bezier(0.215, 0.610, 0.355, 1);
        }

        body.light-mode #gameExperience {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .game-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            text-align: center;
            color: white;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        body.light-mode .game-ui {
            color: #333;
        }

        .game-title {
            font-size: 4rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(138, 107, 255, 0.8);
            background: linear-gradient(45deg, #8a6bff, #ff7eb9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s infinite alternate;
        }

        body.light-mode .game-title {
            background: linear-gradient(45deg, #4facfe, #ff9a9e);
        }

        .game-instructions {
            font-size: 1.5rem;
            max-width: 700px;
            margin: 0 auto 3rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.85);
        }

        body.light-mode .game-instructions {
            color: rgba(0, 0, 0, 0.85);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .game-btn {
            padding: 1rem 2.5rem;
            border-radius: 40px;
            background: var(--game-btn-bg);
            border: 2px solid var(--game-btn-border);
            color: var(--text-light);
            font-size: 1.2rem;
            font-weight: 600;
            cursor: none;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: var(--blur-md);
        }

        .game-btn:hover {
            background: var(--game-btn-hover);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .game-return-btn {
            position: absolute;
            top: 30px;
            left: 30px;
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            background: var(--game-btn-bg);
            border: 2px solid var(--game-btn-border);
            color: var(--text-light);
            font-size: 1rem;
            font-weight: 600;
            cursor: none;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: var(--blur-md);
            z-index: 10;
        }

        .game-return-btn:hover {
            background: var(--game-btn-hover);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px rgba(138, 107, 255, 0.5); }
            100% { text-shadow: 0 0 30px rgba(138, 107, 255, 0.9), 0 0 60px rgba(255, 126, 185, 0.7); }
        }

        /* Transition Effects */
        .transition-particle {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--violet-light);
            box-shadow: 0 0 15px var(--violet-light);
            pointer-events: none;
            z-index: 4000;
            transform: translate(-50%, -50%);
            opacity: 0;
        }

        /* Back to top button */
        .back-to-top {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--primary-gradient);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            box-shadow: var(--shadow-md);
            cursor: none;
            opacity: 0;
            transform: translateY(20px);
            transition: var(--transition);
            z-index: 99;
        }

        .back-to-top.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .back-to-top:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Mode toggle button */
        .theme-toggle {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 60px;
            height: 30px;
            background: var(--glass-bg);
            border-radius: 15px;
            border: 1px solid var(--glass-border);
            cursor: none;
            z-index: 1001;
            backdrop-filter: var(--blur-sm);
            display: flex;
            align-items: center;
            padding: 0 5px;
            transition: background 0.5s ease;
        }

        .theme-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--cursor-color);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        body.light-mode .theme-toggle::before {
            transform: translateX(30px);
            background: var(--cursor-active);
        }

        .theme-icon {
            position: absolute;
            font-size: 0.8rem;
            color: white;
            transition: opacity 0.3s ease;
        }

        .theme-icon.sun {
            left: 8px;
            opacity: 0;
        }

        .theme-icon.moon {
            right: 8px;
            opacity: 1;
        }

        body.light-mode .theme-icon.sun {
            opacity: 1;
            color: #333;
        }

        body.light-mode .theme-icon.moon {
            opacity: 0;
        }

        /* Responsive Design */
        @media (max-width: 992px) {
            .hero h1 {
                font-size: 3.2rem;
            }
            
            .about-content {
                grid-template-columns: 1fr;
                text-align: center;
                gap: 3rem;
            }
            
            .projects-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .nav-links {
                position: fixed;
                top: 0;
                right: -100%;
                height: 100vh;
                width: 70%;
                background: rgba(40, 40, 60, 0.95);
                backdrop-filter: var(--blur-lg);
                flex-direction: column;
                justify-content: center;
                gap: 3rem;
                transition: right 0.4s ease;
                z-index: 900;
            }
            
            .nav-links.active {
                right: 0;
            }
            
            .menu-toggle {
                display: flex;
                z-index: 1000;
            }
            
            .menu-toggle.active span:nth-child(1) {
                transform: rotate(45deg) translate(5px, 9px);
            }
            
            .menu-toggle.active span:nth-child(2) {
                opacity: 0;
            }
            
            .menu-toggle.active span:nth-child(3) {
                transform: rotate(-45deg) translate(5px, -9px);
            }
            
            .hero {
                padding: 4rem 0 3rem;
            }
            
            .hero h1 {
                font-size: 2.8rem;
            }
            
            .hero p {
                font-size: 1.3rem;
            }
            
            .section {
                padding: 4rem 0;
                margin: 2rem 0;
            }
            
            .section h2 {
                font-size: 2.4rem;
            }
            
            .contact-info {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 95%;
            }
            
            .modal-header h2 {
                font-size: 2rem;
            }
            
            .close {
                right: 1.5rem;
                top: 1.8rem;
            }
            
            .game-button {
                padding: 1rem 2rem;
                font-size: 0.9rem;
                bottom: 20px;
                right: 20px;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .game-instructions {
                font-size: 1.1rem;
                padding: 0 20px;
            }
            
            .theme-toggle {
                top: 25px;
                right: 25px;
            }
            
            .game-return-btn {
                top: 20px;
                left: 20px;
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            .hero h1 {
                font-size: 2.3rem;
            }
            
            .hero p {
                font-size: 1.1rem;
            }
            
            .cta-button {
                padding: 1rem 2rem;
            }
            
            .section h2 {
                font-size: 2rem;
            }
            
            .project-card {
                padding: 1.8rem;
            }
            
            .project-links {
                flex-direction: column;
                gap: 0.8rem;
            }
            
            .modal-body {
                padding: 1.8rem;
            }
            
            .modal-header {
                padding: 1.8rem;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 1rem;
            }
            
            .theme-toggle {
                top: 20px;
                right: 20px;
                width: 50px;
                height: 25px;
            }
            
            body.light-mode .theme-toggle::before {
                transform: translateX(20px);
            }
            
            .game-return-btn {
                top: 15px;
                left: 15px;
                padding: 0.5rem 0.8rem;
                font-size: 0.8rem;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #667eea, #764ba2);
            border-radius: 5px;
        }

        body.light-mode ::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #4facfe, #00f2fe);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #5a6ed8, #6842a0);
        }

        body.light-mode ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #3a9bfe, #00d2fe);
        }
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="loader">
            <div class="loader-inner"></div>
            <div class="loader-inner"></div>
            <div class="loader-inner"></div>
        </div>
        <div class="loader-text">Chargement...</div>
        <div class="preloader-particles"></div>
    </div>

    <!-- Canvas pour le réseau neuronal -->
    <canvas id="neuralCanvas"></canvas>
    
    <!-- Système de curseur amélioré -->
    <div class="cursor"></div>
    <div class="cursor-follower"></div>
    <div class="cursor-text">Click!</div>
    
    <!-- Boutons flottants -->
    <div class="back-to-top">
        <i class="fas fa-arrow-up"></i>
    </div>
    
    <!-- Bouton de changement de thème -->
    <div class="theme-toggle" id="themeToggle">
        <i class="fas fa-sun theme-icon sun"></i>
        <i class="fas fa-moon theme-icon moon"></i>
    </div>
    
    <header id="header">
        <nav class="container">
            <div class="logo">
                <i class="fas fa-code"></i>
                Hachem Lamrini
            </div>
            <ul class="nav-links">
                <li><a href="#about"><i class="fas fa-user"></i> À propos</a></li>
                <li><a href="#projects"><i class="fas fa-project-diagram"></i> Projets</a></li>
                <li><a href="#contact"><i class="fas fa-envelope"></i> Contact</a></li>
                <li><a href="Raycasting.html"><i class="fas fa-sun-rays"></i> Raycasting</a></li>
            </ul>
            <button class="menu-toggle" id="menuToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </nav>
    </header>

    <main>
        <section class="hero">
            <div class="container">
                <h1>Développeur Passionné & Créatif</h1>
                <p>Étudiant en 1ère année à Epitech | Spécialisé en développement d'applications innovantes</p>
                <a href="#projects" class="cta-button">
                    <i class="fas fa-rocket"></i> Découvrir mes projets
                </a>
            </div>
        </section>

        <section id="about" class="section">
            <div class="container">
                <h2>À propos de moi</h2>
                <div class="about-content">
                    <div class="profile-img-container">
                        <div class="profile-img">
                            HL
                        </div>
                    </div>
                    <div class="about-text">
                        <p>Bonjour ! Je suis Hachem Lamrini, étudiant passionné en première année à Epitech. Mon parcours dans le développement informatique a commencé très tôt, et aujourd'hui, je me spécialise dans la création d'applications innovantes et de solutions technologiques créatives.</p>
                        
                        <p>À Epitech, j'acquiers des compétences solides en programmation tout en développant ma capacité à résoudre des problèmes complexes. J'aime relever des défis techniques et créer des projets qui ont un impact positif et qui repoussent les limites de la technologie.</p>
                        
                        <p>Je maîtrise plusieurs langages de programmation et technologies, notamment le C, Python, JavaScript, et les frameworks modernes. Mon approche combine rigueur technique et créativité pour produire des solutions élégantes et efficaces.</p>
                        
                        <p>Je suis constamment à la recherche de nouvelles opportunités d'apprentissage et de collaboration sur des projets innovants. Si vous cherchez un développeur passionné et déterminé, n'hésitez pas à me contacter !</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="projects" class="section">
            <div class="container">
                <h2>Mes projets récents</h2>
                <div class="projects-grid">
                    <div class="project-card" data-project="wolf3d">
                        <h3><i class="fas fa-gamepad"></i> Wolf3D</h3>
                        <p>Développement d'un moteur 3D en langage C inspiré de Wolfenstein 3D, avec gestion des collisions, textures dynamiques et animations fluides. Utilisation de l'algorithme de raycasting pour un rendu performant.</p>
                        
                        <div class="tech-stack">
                            <span class="tech-tag">C</span>
                            <span class="tech-tag">CSFML</span>
                            <span class="tech-tag">OpenGL</span>
                            <span class="tech-tag">Algorithmes 3D</span>
                        </div>
                        <div class="project-links">
                            <a href="#" class="project-link fullscreen-btn" onclick="openModal('wolf3d'); event.stopPropagation();">
                                <i class="fas fa-expand"></i> Voir en détail
                            </a>
                            <a href="#" class="project-link code-link" onclick="event.stopPropagation();">
                                <i class="fab fa-github"></i> Code source
                            </a>
                        </div>
                    </div>

                    <div class="project-card" data-project="myworld">
                        <h3><i class="fas fa-globe-americas"></i> MyWorld</h3>
                        <p>Éditeur de terrain 3D en temps réel inspiré de Tycoon Terrain. Créez, modifiez et exportez des cartes avec des effets de relief, textures et éclairage dynamique. Gestion de la génération procédurale de terrains.</p>
                        
                        <div class="tech-stack">
                            <span class="tech-tag">C</span>
                            <span class="tech-tag">CSFML</span>
                            <span class="tech-tag">Projection 3D</span>
                            <span class="tech-tag">Algorithmes de terrain</span>
                        </div>
                        <div class="project-links">
                            <a href="#" class="project-link fullscreen-btn" onclick="openModal('myworld'); event.stopPropagation();">
                                <i class="fas fa-expand"></i> Voir en détail
                            </a>
                            <a href="#" class="project-link code-link" onclick="event.stopPropagation();">
                                <i class="fab fa-github"></i> Code source
                            </a>
                        </div>
                    </div>

                    <div class="project-card" data-project="minishell">
                        <h3><i class="fas fa-terminal"></i> Minishell</h3>
                        <p>Implémentation complète d'un shell Unix en C, avec gestion des pipes, redirections, signaux et commandes intégrées. Support complet des variables d'environnement et de l'historique des commandes.</p>
                        
                        <div class="tech-stack">
                            <span class="tech-tag">C</span>
                            <span class="tech-tag">Systèmes Unix</span>
                            <span class="tech-tag">Gestion de processus</span>
                            <span class="tech-tag">Parsing</span>
                        </div>
                        <div class="project-links">
                            <a href="#" class="project-link fullscreen-btn" onclick="openModal('minishell'); event.stopPropagation();">
                                <i class="fas fa-expand"></i> Voir en détail
                            </a>
                            <a href="#" class="project-link code-link" onclick="event.stopPropagation();">
                                <i class="fab fa-github"></i> Code source
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="contact" class="section contact">
            <div class="container">
                <h2>Contactez-moi</h2>
                <p>Disponible pour des collaborations, stages ou opportunités professionnelles</p>
                <div class="contact-info">
                    <div class="contact-item">
                        <div class="contact-icon">
                            <i class="fas fa-envelope"></i>
                        </div>
                        <div class="contact-text">hachem.lamrini@epitech.eu</div>
                    </div>
                    <div class="contact-item">
                        <a href="https://www.linkedin.com/in/94020028b" target="_blank" rel="noopener noreferrer">
                            <div class="contact-icon">
                                <i class="fab fa-linkedin"></i>
                            </div>
                            <div class="contact-text">LinkedIn / HachemLamrini</div>
                        </a>
                    </div>
                    <div class="contact-item">
                        <a href="https://github.com/Hachem-afk" target="_blank" rel="noopener noreferrer">
                            <div class="contact-icon">
                                <i class="fab fa-github"></i>
                            </div>
                            <div class="contact-text">GitHub / Hachem-afk</div>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Bouton de jeu innovant -->
    <div id="gameButton" class="game-button">
        <span><i class="fas fa-gamepad"></i> Découvrir le jeu</span>
        <div class="button-particles"></div>
    </div>

    <!-- Expérience de jeu -->
    <div id="gameExperience">
        <canvas id="gameCanvas"></canvas>
        <div class="game-ui">
            <h1 class="game-title">Dimension Shift</h1>
            <p class="game-instructions">Naviguez dans les dimensions fractales. Utilisez les touches fléchées pour vous déplacer et la souris pour changer d'angle. Trouvez le portail dimensionnel caché pour revenir au portfolio.</p>
            <div class="game-controls">
                <button class="game-btn" onclick="hideGameExperience()"><i class="fas fa-arrow-left"></i> Retour</button>
                <button class="game-btn" onclick="startGame()"><i class="fas fa-play"></i> Commencer</button>
            </div>
        </div>
        <button class="game-return-btn" onclick="hideGameExperience()">
            <i class="fas fa-arrow-left"></i> Retour
        </button>
    </div>

    <!-- Modal -->
    <div id="projectModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle"><i class="fas fa-project-diagram"></i> Titre du projet</h2>
                <p id="modalSubtitle">Description courte</p>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="modalDescription" class="modal-details">
                    Description détaillée du projet...
                </div>
                <div id="modalTechStack" class="modal-tech-stack">
                    <!-- Tech tags will be inserted here -->
                </div>
                <div id="modalVideo" class="modal-video" style="display: none;">
                    <video controls>
                        <source src="" type="video/mp4">
                    </video>
                </div>
                <div class="modal-actions">
                    <a href="#" id="modalCodeLink" class="modal-btn modal-code-btn">
                        <i class="fab fa-github"></i> Voir le code source
                    </a>
                </div>
            </div>
        </div>
    </div>

    <script>

        function createPreloaderParticles() {
            const particlesContainer = document.querySelector('.preloader-particles');
            const colors = ['#8a6bff', '#6a4bce', '#4d2fa8', '#b19dff', '#ff7eb9'];
            
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'preloader-particle';
                
                const size = Math.random() * 20 + 5;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const tx = Math.random() * 2 - 1;
                const ty = Math.random() * 2 - 1;
                
                particle.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    box-shadow: 0 0 20px ${color};
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    opacity: 0.8;
                    --tx: ${tx};
                    --ty: ${ty};
                    animation: float ${Math.random() * 4 + 4}s infinite ease-in-out ${Math.random() * 2}s;
                `;
                
                particlesContainer.appendChild(particle);
            }
        }
        
        window.addEventListener('load', function() {
            const preloader = document.getElementById('preloader');
            createPreloaderParticles();
            
            setTimeout(() => {
                preloader.style.opacity = '0';
                preloader.style.visibility = 'hidden';
                
                document.querySelector('main').style.opacity = '1';
                document.querySelector('main').style.transform = 'translateY(0)';
                
                initScrollAnimations();
            }, 2000);
        });

        const config = {
            nodeCount: 40,
            maxConnections: 4,
            pulseSpeed: 2.5,
            colors: ['#8a6bff', '#6a4bce', '#4d2fa8', '#b19dff', '#ff7eb9'],
            activeColor: 0,
            nodeRadius: 5,
            lineWidth: 2.5,
            pulseWidth: 6,
            repulsionDistance: 120,
            attractionForce: 0.015,
            connectionDistance: 180
        };

        const canvas = document.getElementById('neuralCanvas');
        const ctx = canvas.getContext('2d');
        const cursor = document.querySelector('.cursor');
        const cursorFollower = document.querySelector('.cursor-follower');
        const cursorText = document.querySelector('.cursor-text');
        const themeToggle = document.getElementById('themeToggle');
        const backToTop = document.querySelector('.back-to-top');

        let nodes = [];
        let pulses = [];
        let mouseX = 0;
        let mouseY = 0;
        let animationId;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let velocity = 0;
        let hoverState = false;
        let clickParticles = [];
        let hoverTextTimeout;

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createNodes();
            animate();
        }

        function createNodes() {
            nodes = [];
            for (let i = 0; i < config.nodeCount; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    radius: config.nodeRadius,
                    connections: [],
                    color: config.colors[Math.floor(Math.random() * config.colors.length)]
                });
            }
            createConnections();
        }

        function createConnections() {
            nodes.forEach(node => {
                node.connections = [];
                for (let i = 0; i < nodes.length; i++) {
                    if (node !== nodes[i] && node.connections.length < config.maxConnections) {
                        const distance = getDistance(node, nodes[i]);
                        if (distance < config.connectionDistance && Math.random() > 0.6) {
                            node.connections.push({
                                target: nodes[i],
                                strength: 1 - (distance / config.connectionDistance)
                            });
                        }
                    }
                }
            });
        }

        function getDistance(node1, node2) {
            const dx = node1.x - node2.x;
            const dy = node1.y - node2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function updateNodes() {
            nodes.forEach(node => {
                const dx = node.x - mouseX;
                const dy = node.y - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < config.repulsionDistance) {
                    const force = (config.repulsionDistance - distance) / config.repulsionDistance;
                    node.vx += (dx / distance) * force * 0.4;
                    node.vy += (dy / distance) * force * 0.4;
                }
            });

            nodes.forEach(node => {
                node.connections.forEach(conn => {
                    const dx = conn.target.x - node.x;
                    const dy = conn.target.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const force = config.attractionForce * conn.strength;
                        node.vx += (dx / distance) * force;
                        node.vy += (dy / distance) * force;
                    }
                });
                node.x += node.vx;
                node.y += node.vy;
                if (node.x < node.radius || node.x > canvas.width - node.radius) {
                    node.vx *= -0.8;
                    node.x = node.x < node.radius ? node.radius : canvas.width - node.radius;
                }
                
                if (node.y < node.radius || node.y > canvas.height - node.radius) {
                    node.vy *= -0.8;
                    node.y = node.y < node.radius ? node.radius : canvas.height - node.radius;
                }

                node.vx *= 0.98;
                node.vy *= 0.98;
            });
            if (Math.random() < 0.07) {
                createPulse();
            }
            updatePulses();
        }

        function createPulse() {
            if (nodes.length > 0) {
                const startNode = nodes[Math.floor(Math.random() * nodes.length)];
                
                if (startNode.connections.length > 0) {
                    const connection = startNode.connections[Math.floor(Math.random() * startNode.connections.length)];
                    pulses.push({
                        start: startNode,
                        end: connection.target,
                        progress: 0,
                        width: config.pulseWidth,
                        color: config.colors[config.activeColor],
                        speed: config.pulseSpeed * (0.5 + Math.random() * 0.7)
                    });
                    config.activeColor = (config.activeColor + 1) % config.colors.length;
                }
            }
        }
        
        function updatePulses() {
            for (let i = pulses.length - 1; i >= 0; i--) {
                pulses[i].progress += 0.01 * pulses[i].speed;
                
                if (pulses[i].progress >= 1) {
                    pulses.splice(i, 1);
                }
            }
        }
        
        function drawNetwork() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.lineWidth = config.lineWidth;
            
            nodes.forEach(node => {
                node.connections.forEach(conn => {
                    const alpha = 0.5 + 0.4 * conn.strength;
                    ctx.strokeStyle = `rgba(138, 107, 255, ${alpha})`;
                    
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(conn.target.x, conn.target.y);
                    ctx.stroke();
                });
            });
            pulses.forEach(pulse => {
                const start = pulse.start;
                const end = pulse.end;
                const x = start.x + (end.x - start.x) * pulse.progress;
                const y = start.y + (end.y - start.y) * pulse.progress;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, pulse.width * 2);

                gradient.addColorStop(0, pulse.color);
                gradient.addColorStop(0.7, pulse.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, pulse.width * 2, 0, Math.PI * 2);
                ctx.fill();
            });

            nodes.forEach(node => {
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius * 2.5
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                gradient.addColorStop(0.8, node.color);
                gradient.addColorStop(1, 'rgba(138, 107, 255, 0.5)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowColor = node.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function animate() {
            updateNodes();
            drawNetwork();
            updateCursorEffects();
            animationId = requestAnimationFrame(animate);
        }

        function updateCursorEffects() {
            const deltaX = mouseX - lastMouseX;
            const deltaY = mouseY - lastMouseY;
            velocity = Math.sqrt(deltaX * deltaY);
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            updateClickParticles();
        }

        function updateClickParticles() {
            for (let i = clickParticles.length - 1; i >= 0; i--) {
                const particle = clickParticles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1;
                particle.opacity -= 0.02;
                particle.element.style.left = `${particle.x}px`;
                particle.element.style.top = `${particle.y}px`;
                particle.element.style.opacity = particle.opacity;
                particle.element.style.transform = `translate(-50%, -50%) scale(${particle.scale})`;
                if (particle.opacity <= 0) {
                    particle.element.remove();
                    clickParticles.splice(i, 1);
                }
            }
        }
        
        function createClickParticles(x, y) {
            const count = 15;
            const colors = ['#ff7eb9', '#8a6bff', '#6a4bce', '#b19dff', '#ffffff'];
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'cursor-particle';
                
                const size = Math.random() * 8 + 4;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                particle.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    box-shadow: 0 0 10px ${color};
                    left: ${x}px;
                    top: ${y}px;
                    opacity: 1;
                `;
                
                document.body.appendChild(particle);
                
                clickParticles.push({
                    element: particle,
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    opacity: 1,
                    scale: Math.random() * 0.5 + 0.5
                });
            }
        }

        function showCursorText(text, duration = 1000) {
            cursorText.textContent = text;
            cursorText.style.opacity = 1;
            cursorText.style.transform = 'translate(-50%, -50%) scale(1)';
            if (hoverTextTimeout) clearTimeout(hoverTextTimeout);
            hoverTextTimeout = setTimeout(() => {
                cursorText.style.opacity = 0;
                cursorText.style.transform = 'translate(-50%, -50%) scale(0.8)';
            }, duration);
        }

        function initCursor() {
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                cursor.style.left = `${e.clientX}px`;
                cursor.style.top = `${e.clientY}px`;
                cursorText.style.left = `${e.clientX}px`;
                cursorText.style.top = `${e.clientY - 40}px`;
                setTimeout(() => {
                    cursorFollower.style.left = `${e.clientX}px`;
                    cursorFollower.style.top = `${e.clientY}px`;
                }, 50);
            });

            const interactiveElements = document.querySelectorAll('button, a, .project-card, .cta-button, .contact-item, .nav-links a, .project-link, .game-button');
            
            interactiveElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    cursor.classList.add('active');
                    cursorFollower.classList.add('expanded');
                    
                    if (el.classList.contains('cta-button')) {
                        showCursorText('Go!');
                    } else if (el.classList.contains('project-link')) {
                        showCursorText('Open');
                    } else if (el.classList.contains('game-button')) {
                        showCursorText('Play!');
                    } else if (el.classList.contains('theme-toggle')) {
                        showCursorText('Switch Theme');
                    }
                });
                
                el.addEventListener('mouseleave', () => {
                    cursor.classList.remove('active');
                    cursorFollower.classList.remove('expanded');
                });
            });

            document.addEventListener('mousedown', (e) => {
                cursor.classList.add('clicked');
                cursorFollower.classList.add('clicked');
                createClickParticles(e.clientX, e.clientY);
                showCursorText('Click!', 300);
            });
            
            document.addEventListener('mouseup', () => {
                cursor.classList.remove('clicked');
                cursorFollower.classList.remove('clicked');
            });

            const projectCards = document.querySelectorAll('.project-card');
            projectCards.forEach(card => {
                card.addEventListener('mouseenter', () => {
                    showCursorText('View Project');
                });
            });

            const logo = document.querySelector('.logo');
            logo.addEventListener('mouseenter', () => {
                showCursorText('Home');
            });
        }

        const menuToggle = document.getElementById('menuToggle');
        const navLinks = document.querySelector('.nav-links');
        
        menuToggle.addEventListener('click', () => {
            menuToggle.classList.toggle('active');
            navLinks.classList.toggle('active');
        });

        document.querySelectorAll('.nav-links a').forEach(link => {
            link.addEventListener('click', () => {
                menuToggle.classList.remove('active');
                navLinks.classList.remove('active');
            });
        });

        const header = document.getElementById('header');
        
        window.addEventListener('scroll', () => {
            if (window.scrollY > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
            

            if (window.scrollY > 500) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        });

        backToTop.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                
                const targetId = this.getAttribute('href');
                if (targetId === '#') return;
                
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 80,
                        behavior: 'smooth'
                    });
                }
            });
        });

        const modal = document.getElementById('projectModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalSubtitle = document.getElementById('modalSubtitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalTechStack = document.getElementById('modalTechStack');
        const modalVideo = document.getElementById('modalVideo');
        const modalCodeLink = document.getElementById('modalCodeLink');

        const projects = {
            wolf3d: {
                title: "Wolf3D",
                subtitle: "Moteur 3D inspiré de Wolfenstein",
                description: "Ce projet est une implémentation complète d'un moteur 3D utilisant la technique du raycasting, similaire à celle utilisée dans le jeu Wolfenstein 3D. Développé en C avec la bibliothèque CSFML, ce moteur permet de naviguer dans un environnement 3D en temps réel avec des textures dynamiques, une gestion des collisions précise et un système d'éclairage.<br><br>Les fonctionnalités incluent :<ul><li>Génération de cartes à partir de fichiers de configuration</li><li>Textures dynamiques pour les murs, sols et plafonds</li><li>Système de collisions avec les murs et objets</li><li>Éclairage dynamique et ombres portées</li><li>Interface utilisateur intuitive avec minimap</li><li>Optimisation des performances pour un rendu fluide</li></ul>",
                techStack: ["C", "CSFML", "OpenGL", "Algorithmes 3D", "Mathématiques"],
                videoSrc: "assets/Wolf3D.mp4"
            },
            myworld: {
                title: "MyWorld",
                subtitle: "Éditeur de terrain 3D procédural",
                description: "MyWorld est un éditeur de terrain 3D en temps réel qui permet de créer, modifier et exporter des environnements complexes. Inspiré des outils de création de jeux comme Tycoon Terrain, ce projet offre une interface intuitive pour sculpter le terrain, appliquer des textures et configurer des effets environnementaux.<br><br>Principales caractéristiques :<ul><li>Génération procédurale de terrains avec bruit de Perlin</li><li>Outils de sculpture : élévation, abaissement, lissage</li><li>Système de textures multicouches avec blending</li><li>Éclairage dynamique et gestion des ombres</li><li>Export des cartes dans différents formats</li><li>Gestion de l'eau avec réflexion et réfraction</li></ul>",
                techStack: ["C", "CSFML", "Projection 3D", "Algorithmes de terrain", "OpenGL"],
                videoSrc: "assets/MyWorld.mp4"
            },
            minishell: {
                title: "Minishell",
                subtitle: "Shell Unix complet en C",
                description: "Minishell est une implémentation complète d'un shell Unix en langage C, offrant toutes les fonctionnalités essentielles d'un terminal moderne. Ce projet démontre une compréhension approfondie des systèmes d'exploitation, de la gestion des processus et des entrées/sorties.<br><br>Fonctionnalités implémentées :<ul><li>Parsing avancé des commandes avec gestion des quotes</li><li>Redirections d'entrée/sortie (>, <, >>, <<)</li><li>Pipes multiples avec gestion des processus</li><li>Commandes intégrées (cd, echo, exit, env, etc.)</li><li>Gestion des signaux (Ctrl-C, Ctrl-D, Ctrl-\\)</li><li>Variables d'environnement et historique des commandes</li><li>Autocomplétion avec la touche Tab</li></ul>",
                techStack: ["C", "Systèmes Unix", "Gestion de processus", "Parsing", "Signaux"],
                videoSrc: "assets/Minishell.mp4"
            }
        };
        
        function openModal(projectId) {
            const project = projects[projectId];

            if (!project) return;
            modalTitle.innerHTML = `<i class="fas fa-project-diagram"></i> ${project.title}`;
            modalSubtitle.textContent = project.subtitle;
            modalDescription.innerHTML = project.description;
            modalTechStack.innerHTML = '';
            project.techStack.forEach(tech => {
                const tag = document.createElement('span');
                tag.className = 'modal-tech-tag';
                tag.textContent = tech;
                modalTechStack.appendChild(tag);
            });
            if (project.videoSrc) {
                modalVideo.style.display = 'block';
                modalVideo.querySelector('source').src = project.videoSrc;
                modalVideo.querySelector('video').load();
            } else {
                modalVideo.style.display = 'none';
            }
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }
        
        function closeModal() {
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
            const video = modalVideo.querySelector('video');
            if (video) video.pause();
        }
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('show')) {
                closeModal();
            }
        });

        function initScrollAnimations() {
            const sections = document.querySelectorAll('.section');
            const projectCards = document.querySelectorAll('.project-card');
            const contactItems = document.querySelectorAll('.contact-item');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('active');
                    }
                });
            }, {
                threshold: 0.1
            });
            
            sections.forEach(section => {
                observer.observe(section);
            });
            
            projectCards.forEach(card => {
                observer.observe(card);
            });
            
            contactItems.forEach(item => {
                observer.observe(item);
            });
        }
        
        const gameButton = document.getElementById('gameButton');
        const gameExperience = document.getElementById('gameExperience');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameUI = document.querySelector('.game-ui');
        
        let gameScene, gameCamera, gameRenderer, gameObjects = [];
        
        gameButton.addEventListener('click', showGameExperience);
        
        function showGameExperience() {
            createTransitionEffect();
            document.querySelectorAll('header, main, #gameButton, .back-to-top, .theme-toggle').forEach(el => {
                el.style.opacity = '0';
                el.style.pointerEvents = 'none';
            });
            setTimeout(() => {
                gameExperience.style.display = 'block';
                setTimeout(() => {
                    gameExperience.style.opacity = '1';
                    setTimeout(() => {
                        gameUI.style.opacity = '1';
                    }, 500);
                }, 50);
            }, 1000);
        }
        
        function hideGameExperience() {
            gameExperience.style.opacity = '0';
            setTimeout(() => {
                gameExperience.style.display = 'none';
                document.querySelectorAll('header, main, #gameButton, .back-to-top, .theme-toggle').forEach(el => {
                    el.style.opacity = '1';
                    el.style.pointerEvents = 'all';
                });
            }, 1000);
        }
        
        function createTransitionEffect() {
            for (let i = 0; i < 150; i++) {
                const particle = document.createElement('div');
                particle.className = 'transition-particle';
                
                const size = Math.random() * 30 + 10;
                const color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                
                particle.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    box-shadow: 0 0 20px ${color};
                    left: ${Math.random() * 100}vw;
                    top: ${Math.random() * 100}vh;
                    opacity: 0;
                `;
                
                document.body.appendChild(particle);
                
                const duration = 1 + Math.random() * 2;
                const delay = Math.random() * 0.5;
                const targetX = Math.random() * 100;
                const targetY = Math.random() * 100;
                
                particle.animate([
                    { 
                        opacity: 0,
                        transform: 'translate(-50%, -50%) scale(0)'
                    },
                    { 
                        opacity: 1,
                        transform: 'translate(-50%, -50%) scale(1)',
                        offset: 0.1
                    },
                    { 
                        opacity: 1,
                        transform: `translate(${targetX - 50}vw, ${targetY - 50}vh) scale(0.2)`
                    }
                ], {
                    duration: duration * 1000,
                    delay: delay * 1000,
                    easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)',
                    fill: 'forwards'
                });
                setTimeout(() => {
                    particle.remove();
                }, (duration + delay) * 1000);
            }
        }
        
        function startGame() {
            gameUI.style.opacity = '0';
            initGame();
        }
        
        function initGame() {
            gameScene = new THREE.Scene();
            gameCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            gameCamera.position.z = 5;
            gameRenderer = new THREE.WebGLRenderer({ 
                canvas: gameCanvas,
                antialias: true,
                alpha: true
            });
            gameRenderer.setSize(window.innerWidth, window.innerHeight);
            gameRenderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            gameScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            gameScene.add(directionalLight);
            createFractalBackground();
            animateGame();
        }
        
        function createFractalBackground() {
            const geometry = new THREE.IcosahedronGeometry(1, 3);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x8a6bff,
                wireframe: true,
                emissive: 0x4d2fa8,
                emissiveIntensity: 0.5
            });
            
            for (let i = 0; i < 20; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = (Math.random() - 0.5) * 20;
                mesh.position.y = (Math.random() - 0.5) * 20;
                mesh.position.z = (Math.random() - 0.5) * 20;
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.y = Math.random() * Math.PI;
                
                const scale = 0.5 + Math.random() * 1.5;
                mesh.scale.set(scale, scale, scale);
                
                gameScene.add(mesh);
                gameObjects.push(mesh);
            }
        }
        
        function animateGame() {
            requestAnimationFrame(animateGame);
            
            gameObjects.forEach((obj, index) => {
                obj.rotation.x += 0.005 * (index % 3 + 1);
                obj.rotation.y += 0.003 * (index % 4 + 1);
                const scale = 0.8 + Math.sin(Date.now() * 0.001 + index) * 0.2;
                obj.scale.set(scale, scale, scale);
            });
            gameCamera.position.x = Math.sin(Date.now() * 0.001) * 3;
            gameCamera.position.y = Math.cos(Date.now() * 0.0007) * 2;
            gameCamera.position.z = 5 + Math.sin(Date.now() * 0.0005) * 2;
            gameCamera.lookAt(0, 0, 0);
            gameRenderer.render(gameScene, gameCamera);
        }
        
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (gameRenderer) {
                gameCamera.aspect = window.innerWidth / window.innerHeight;
                gameCamera.updateProjectionMatrix();
                gameRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLightMode = document.body.classList.contains('light-mode');
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark');
            
            const transitionEffect = document.createElement('div');
            transitionEffect.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: ${isLightMode ? '#ffffff' : '#000000'};
                opacity: 0.8;
                z-index: 9999;
                pointer-events: none;
                animation: fadeOut 1s ease forwards;
            `;
            
            document.body.appendChild(transitionEffect);
            setTimeout(() => {
                transitionEffect.remove();
            }, 1000);
        }
        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        }
        window.addEventListener('load', () => {
            initCanvas();
            initCursor();
            initScrollAnimations();
            applySavedTheme();
            themeToggle.addEventListener('click', toggleTheme);
        });
        window.addEventListener('resize', handleResize);
    </script>
</body>
</html><!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raytracing Games - Portfolio Hachem Lamrini</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="interactive-bg"></div>
    <canvas class="bg-canvas" id="bgCanvas"></canvas>
    
    <div class="custom-cursor" id="cursor"></div>
    <div class="ambient-light" id="ambientLight"></div>
    
    <a href="#" class="back-button" onclick="window.history.back()">
        <i class="fas fa-arrow-left"></i> Retour au portfolio
    </a>

    <div class="container">
        <div class="header">
            <h1 class="title">Raytracing Engine</h1>
            <p class="subtitle">Simulations physiques ultra-réalistes avec raytracing optimisé</p>
        </div>

        <div class="games-grid">
            <!-- Ocean Raytracing Simulation -->
            <div class="game-card" onclick="startRaytracing('ocean')">
                <div class="loading-overlay" id="oceanLoading">
                    <div class="loading-spinner"></div>
                </div>
                <canvas id="oceanCanvas" class="game-canvas" width="500" height="450"></canvas>
                <div class="performance-info" id="oceanPerf">FPS: 0 | Rayons: 0</div>
                <div class="game-info">
                    <h3 class="game-title">Ocean Raytracing</h3>
                    <p class="game-desc">Simulation océanique avec raytracing volumétrique et caustiques dynamiques.</p>
                </div>
            </div>

            <!-- Crystal Fractal Raytracer -->
            <div class="game-card" onclick="startRaytracing('crystal')">
                <div class="loading-overlay" id="crystalLoading">
                    <div class="loading-spinner"></div>
                </div>
                <canvas id="crystalCanvas" class="game-canvas" width="500" height="450"></canvas>
                <div class="performance-info" id="crystalPerf">FPS: 0 | Fractales: 0</div>
                <div class="game-info">
                    <h3 class="game-title">Crystal Fractal Raytracer</h3>
                    <p class="game-desc">Rendu de cristaux fractals avec raytracing récursif et dispersion chromatique.</p>
                </div>
            </div>
        </div>

        <!-- Error message display -->
        <div id="errorMessage" class="error-message" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i>
            <span id="errorText"></span>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/utils.js"></script>
    <script src="js/performance-monitor.js"></script>
    <script src="js/particle-system.js"></script>
    <script src="js/raytracing-engine.js"></script>
    <script src="js/ocean-simulation.js"></script>
    <script src="js/crystal-simulation.js"></script>
    
    <script>
        // Global application state
        let activeGame = null;
        let bgAnimationId;
        let mouseX = 0, mouseY = 0;
        let cursorTrails = [];
        
        // Performance monitor instance
        let performanceMonitor;
        
        // Particle system instance
        let particleSystem;
        
        // Raytracing engines
        let oceanEngine, crystalEngine;

        // Initialize application
        function init() {
            try {
                // Check WebGL support
                if (!Utils.checkWebGLSupport()) {
                    showError("WebGL n'est pas supporté par votre navigateur. Veuillez utiliser un navigateur moderne.");
                    return;
                }

                // Initialize performance monitor
                performanceMonitor = new PerformanceMonitor();
                
                // Initialize particle system
                particleSystem = new ParticleSystem(document.getElementById('bgCanvas'));
                
                // Initialize raytracing engines
                oceanEngine = new OceanSimulation();
                crystalEngine = new CrystalSimulation();
                
                // Initialize cursor effects
                initCursorEffects();
                
                // Start background animation
                startBackgroundAnimation();
                
                console.log("Raytracing portfolio initialized successfully");
                
            } catch (error) {
                console.error("Initialization error:", error);
                showError("Erreur d'initialisation: " + error.message);
            }
        }

        // Initialize cursor effects
        function initCursorEffects() {
            const cursor = document.getElementById('cursor');
            const ambientLight = document.getElementById('ambientLight');
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Update cursor position
                cursor.style.left = (mouseX - 10) + 'px';
                cursor.style.top = (mouseY - 10) + 'px';
                
                // Update ambient light position
                ambientLight.style.left = (mouseX - 150) + 'px';
                ambientLight.style.top = (mouseY - 150) + 'px';
                
                // Add cursor trail
                addCursorTrail(mouseX, mouseY);
            });
        }

        // Add cursor trail effect
        function addCursorTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = (x - 3) + 'px';
            trail.style.top = (y - 3) + 'px';
            document.body.appendChild(trail);
            
            cursorTrails.push(trail);
            
            // Animate trail
            setTimeout(() => {
                trail.style.opacity = '0';
                trail.style.transform = 'scale(0)';
            }, 50);
            
            // Remove trail after animation
            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
                const index = cursorTrails.indexOf(trail);
                if (index > -1) {
                    cursorTrails.splice(index, 1);
                }
            }, 500);
            
            // Limit trail count for performance
            if (cursorTrails.length > 10) {
                const oldTrail = cursorTrails.shift();
                if (oldTrail.parentNode) {
                    oldTrail.parentNode.removeChild(oldTrail);
                }
            }
        }

        // Start background animation
        function startBackgroundAnimation() {
            function animate() {
                particleSystem.update(mouseX, mouseY);
                particleSystem.render();
                bgAnimationId = requestAnimationFrame(animate);
            }
            animate();
        }

        // Start raytracing simulation
        function startRaytracing(type) {
            if (activeGame === type) return;
            
            // Stop previous game
            if (activeGame) {
                stopRaytracing(activeGame);
            }
            
            activeGame = type;
            
            try {
                const loadingElement = document.getElementById(type + 'Loading');
                loadingElement.style.display = 'flex';
                
                setTimeout(() => {
                    if (type === 'ocean') {
                        oceanEngine.init('oceanCanvas', 'oceanPerf');
                        oceanEngine.start();
                    } else if (type === 'crystal') {
                        crystalEngine.init('crystalCanvas', 'crystalPerf');
                        crystalEngine.start();
                    }
                    
                    loadingElement.style.display = 'none';
                }, 1000);
                
            } catch (error) {
                console.error(`Error starting ${type} simulation:`, error);
                showError(`Erreur lors du démarrage de la simulation ${type}: ${error.message}`);
                document.getElementById(type + 'Loading').style.display = 'none';
            }
        }

        // Stop raytracing simulation
        function stopRaytracing(type) {
            try {
                if (type === 'ocean' && oceanEngine) {
                    oceanEngine.stop();
                } else if (type === 'crystal' && crystalEngine) {
                    crystalEngine.stop();
                }
            } catch (error) {
                console.error(`Error stopping ${type} simulation:`, error);
            }
        }

        // Show error message
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            
            errorText.textContent = message;
            errorElement.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 5000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (particleSystem) {
                particleSystem.resize();
            }
            
            if (oceanEngine && activeGame === 'ocean') {
                oceanEngine.resize();
            }
            
            if (crystalEngine && activeGame === 'crystal') {
                crystalEngine.resize();
            }
        });

        // Handle page visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Pause animations when tab is not visible
                if (bgAnimationId) {
                    cancelAnimationFrame(bgAnimationId);
                }
                if (activeGame) {
                    stopRaytracing(activeGame);
                }
            } else {
                // Resume animations when tab becomes visible
                startBackgroundAnimation();
                if (activeGame) {
                    startRaytracing(activeGame);
                }
            }
        });

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
        
        // Handle page unload for cleanup
        window.addEventListener('beforeunload', () => {
            if (bgAnimationId) {
                cancelAnimationFrame(bgAnimationId);
            }
            if (activeGame) {
                stopRaytracing(activeGame);
            }
        });
    </script>
</body>
</html>